{"pages":[{"title":"about","text":"关于我 一枚无名小辈，相信知识就是力量。 会一直在路上…… QQ：1870949565Email: 1870949565@qq.com","link":"/about/index.html"},{"title":"tages","text":"","link":"/tages/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"ES6模块化与异步编程高级用法","text":"ES6 模块化回顾：node.js 中如何实现模块化 node.js 遵循了 CommonJS 的模块化规范。其中： 导入其它模块使用 require() 方法 模块对外共享成员使用 module.exports 对象 模块化的好处： 大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。 前端模块化规范的分类在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。 但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准，例如： AMD 和 CMD 适用于浏览器端的 Javascript 模块化 CommonJS 适用于服务器端的 Javascript 模块化 太多的模块化规范给开发者增加了学习的难度与开发的成本。因此，大一统的 ES6 模块化规范诞生了！ 什么是 ES6 模块化规范ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。 ES6 模块化规范中定义： 每个 js 文件都是一个独立的模块 导入其它模块成员使用 import 关键字 向外共享模块成员使用 export 关键字 在 node.js 中体验 ES6 模块化node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照 如下两个步骤进行配置： ① 确保安装了 v14.15.1 或更高版本的 node.js ② 在 package.json 的根节点中添加 &quot;type&quot;: &quot;module&quot; 节点 ES6 模块化的基本语法ES6 的模块化主要包含如下 3 种用法： 默认导出与默认导入 按需导出与按需导入 直接导入并执行模块中的代码 默认导出默认导出的语法： export default 默认导出的成员 12345678let n1 = 10 //定义模块私有成员 n1let n2 = 20 //定义模块私有成员 n2 (外界访问不到 n2 ，因为它没有被共享出去function show() {} //定义模块私有方法 showexport default { //使用export default 默认导出语法，向外共享n1和 show 两个成员 n1, show} 默认导出的注意事项每个模块中，只允许使用唯一的一次 export default，否则会报错！ 默认导入默认导入的语法： import 接收名称 from '模块标识符' 1234567// 从01_m1.js 模块中导入 export default 向外共享的成员// 并使用m1 成员进行接收import m1 from './01_m1.js'//打印输出的结果为;// { n1: 10，show: [Function: show] }console.log(m1) 默认导入的注意事项默认导入时的接收名称可以任意名称，只要是合法的成员名称即可。（不能以数字开头） 按需导出按需导出的语法： export 按需导出的成员 1234567// 当前模块为 03_m2.js// 向外按需导出变量s1export let s1 = 'aaa'// 向外按需导出变量s2export let s2 = 'ccc'//向外按需导出方法sayexport function say() {} 按需导出的注意事项每个模块中可以使用多次按需导出 按需导入按需导入的语法： import { s1 } from '模块标识符' 123456// 导入模块成员import { s1, s2, say } from './03_m2.js'console.log(s1) //打印输出 aaaconsole.log(s2) //打印输出 cccconsole.log(say) //打印输出 [Function: say] 按需导入的注意事项 按需导入的成员名称必须和按需导出的名称保持一致 按需导入时，可以使用 as 关键字进行重命名 按需导入可以和默认导入一起使用 直接导入并执行模块中的代码如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码，示例代码如下： 12345678910// 当前文件模块为05_m3.js// 在当前模块中执行一个 for循环操作for (let i = 0; i &lt; 3; i++) { console.log(i)}//--------------------分割线--------------------// 直接导入并执行模块代码，不需要得到模块向外共享的成员import './05_m3.js' Promise回调地狱多层回调函数的相互嵌套，就形成了回调地狱。示例代码如下 1234567891011setTimeout(() =&gt; { // 第1层回调函数 console.log('延时1秒后输出') setTimeout(() =&gt; { // 第2层回调函数 console.log('再延时2秒后输出') setTimeout(() =&gt; { // 第3层回调函数 console.log( '再延时3秒后输出') }，3000) }，2000)},1000) 回调地狱的缺点： 代码耦合性太强，牵一发而动全身，难以维护 大量冗余的代码相互嵌套，代码的可读性变差 如何解决回调地狱的问题为了解决回调地狱的问题，ES6（ECMAScript 2015）中新增了 Promise 的概念。 Promise 的基本概念① Promise 是一个构造函数 我们可以创建 Promise 的实例 const p = new Promise() new 出来的 Promise 实例对象，代表一个异步操作 ② Promise.prototype 上包含一个 .then() 方法 每一次 new Promise() 构造函数得到的实例对象 都可以通过原型链的方式访问到 .then() 方法，例如 p.then() ③ .then() 方法用来预先指定成功和失败的回调函数 p.then(成功的回调函数，失败的回调函数) p.then(result =&gt; { }, error =&gt; { }) 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的 基于回调函数按顺序读取文件内容123456789101112131415//读取文件1.txtfs.readFile('./files/1.txt', 'utf8', (err1，r1) =&gt; { if (err1) return console.log(err1.message) // 读取文件1失败 console.log(r1) // 读取文件 1 成功 // 读取文件 2.txt fs.readFile('./files/2.txt', 'utf8', (err2,r2) =&gt; { if (err2) return console.log(err2.message) // 读取文件2失败 console.log(r2) // 读取文件 2 成功 // 读取文件 3.txt fs.readFile('./files/3.txt', 'utf8',(err3,r3) =&gt; { if (err3) return console.log(err3.message) // 读取文件3失败 console.log(r3) // 读取文件 3 成功 }) })}) 基于 then-fs 读取文件内容由于 node.js 官方提供的 fs 模块仅支持以回调函数的方式读取文件，不支持 Promise 的调用方式。因此，需要先运行如下的命令，安装 then-fs 这个第三方包，从而支持我们基于 Promise 的方式读取文件的内容： 1npm i then-fs then-fs 的基本使用调用 then-fs 提供的 readFile() 方法，可以异步地读取文件的内容，它的返回值是 Promise 的实例对象。因此可以调用 .then() 方法为每个 Promise 异步操作指定成功和失败之后的回调函数。示例代码如下： 12345678910/*** 基于Promise的方式读取文件* /import thenFs from 'then-fs'// 注意: .then()中的失败回调是可选的，可以被省略thenFs.readFile('./files/1.txt', 'utf8').then(r1 =&gt; { console.log(r1) }, err1 =&gt; { console.log(err1.message) })thenFs.readFile('./files/2.txt', 'utf8').then(r2 =&gt; { console.log(r2) }, err2 =&gt; { console.log(err2.message) })thenFs.readFile('./files/3.txt', 'utf8').then(r3 =&gt; { console.log(r3) }, err3 =&gt; { console.log(err3.message) }) 注意：上述的代码无法保证文件的读取顺序，需要做进一步的改进！ then() 方法的特性如果上一个 .then() 方法中返回了一个新的 Promise 实例对象，则可以通过下一个 .then() 继续进行处理。通 过 .then() 方法的链式调用，就解决了回调地狱的问题。 基于 Promise 按顺序读取文件的内容Promise 支持链式调用，从而来解决回调地狱的问题。示例代码如下： 1234567891011121314151617thenFs.readFile('./files/1.txt','utf8') // 返回值是 Promise的实例对象 // 通过 .then 为第一个 Promise 实例指定成功之后的回调函数 .then((r1) =&gt;{ console.log(r1) // 在第一个.then 中返回一个新的 Promise 实例对象 return thenFs.readFile('./files/2.txt', utf8') }) // 继续调用.then，为上一个 .then 的返回值(新的 Promise 实例）指定成功之后的回调函数 .then((r2) =&gt;{ console.log(r2) // 在第二个 .then 中再返回一个新的 Promise 实例对象 return thenFs.readFile('.lfiles/3.txt', 'utf8' ) }) // 继续调用 .then，为上一个 .then 的返回值（新的 Promise 实例）指定成功之后的回调函数 .then((r3)=&gt; { console.log(r3) }) 通过 .catch 捕获错误在 Promise 的链式操作中如果发生了错误，可以使用 Promise.prototype.catch 方法进行捕获和处理： 123456789101112131415thenFs.readFile('./files/11.txt','utf8') // 文件不存在导致读取失败，后面的 3 个 .then 都不执行 .then((r1) =&gt;{ console.log(r1) return thenFs.readFile('./files/2.txt', utf8') }) .then((r2) =&gt;{ console.log(r2) return thenFs.readFile('.lfiles/3.txt', 'utf8' ) }) .then((r3)=&gt; { console.log(r3) }) .catch(err =&gt; { // 捕获第 1 行发生的错误，并输出错误的消息 console.log(err.message) }) 如果不希望前面的错误导致后续的 .then 无法正常执行，则可以将 .catch 的调用提前，示例代码如下： 12345678910111213141516thenFs.readFile('./files/11.txt','utf8') // 文件不存在导致读取失败 .catch(err =&gt; { // 捕获第 1 行发生的错误，并输出错误的消息 console.log(err.message) // 由于错误已被及时处理，不影响后续 .then 的正常执行 }) .then((r1) =&gt;{ console.log(r1) // 输出 undefined return thenFs.readFile('./files/2.txt', utf8') }) .then((r2) =&gt;{ console.log(r2) // 正常输出 return thenFs.readFile('.lfiles/3.txt', 'utf8' ) }) .then((r3)=&gt; { console.log(r3) // 正常输出 }) Promise.all() 方法Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）。示例代码如下： 1234567891011121314// 1．定义一个数组，存放 3 个读文件的异步操作const promiseArr = [ thenFs.readFile('./files/11.txt', 'utf8'), thenFs.readFile('./files/2.txt', 'utf8'), thenFs.readFile('./files/3.txt', 'utf8'),]//2．将 Promise 的数组，作为 Promise.all() 的参数Promise.all(promiseArr) .then(([r1，r2，r3]) =&gt; { // 2.1 所有文件读取成功（等待机制） console.log(r1, r2, r3) }) .catch(err =&gt; { // 2.2 捕获 Promise 异步操作中的错误 console.log(err.message) ) Promise.race() 方法Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的 .then 操作（赛跑机制）。示例代码如下： 1234567891011121314// 1．定义一个数组，存放 3 个读文件的异步操作const promiseArr = [ thenFs.readFile('./files/11.txt', 'utf8'), thenFs.readFile('./files/2.txt', 'utf8'), thenFs.readFile('./files/3.txt', 'utf8'),]//2．将 Promise 的数组，作为 Promise.race() 的参数Promise.race(promiseArr) .then(result) =&gt; { // 2.1 只要任一个异步操作完成,就立即执行下一步的.then操作（赛跑机制） console.log(result) }) .catch(err =&gt; { // 2.2 捕获 Promise 异步操作中的错误 console.log(err.message) ) 基于 Promise 封装读文件的方法方法的封装要求： 方法的名称要定义为 getFile 方法接收一个形参 fpath，表示要读取的文件的路径 方法的返回值为 Promise 实例对象 getFile 方法的基本定义123456// 1．方法的名称为getFile// 2．方法接收一个形参fpath，表示要读取的文件的路径function getFile(fpath) { // 3．方法的返回值为 Promise的实例对象 return new Promise()} 注意：第 5 行代码中的 new Promise() 只是创建了一个形式上的异步操作。 创建具体的异步操作如果想要创建具体的异步操作，则需要在 new Promise() 构造函数期间，传递一个 function 函数，将具体的 异步操作定义到 function 函数内部。示例代码如下： 123456789// 1．方法的名称为getFile// 2．方法接收一个形参fpath，表示要读取的文件的路径function getFile(fpath) { // 3．方法的返回值为 Promise的实例对象 return new Promise(function() { // 4. 下面代码。表示这是一个具体的、读文件的异步操作 fs.readFile(fpath, 'utf8', (err, dataStr) =&gt; { }) })} 获取 .then 的两个实参通过 .then() 指定的成功和失败的回调函数，可以在 function 的形参中进行接收，示例代码如下： 12345678910111213function getFile(fpath) { // resolve 形参是 : 调用 getFiles() 方法时，通过 .then 指定的&quot;成功的&quot;回调函数 // reject 形参是 : 调用 getFiles() 方法时，通过 .then 指定的&quot;失败的&quot;回调函数 return new Promise(function(resolve, reject) { fs.readFile(fpath, 'utf8', (err, dataStr) =&gt; { if(err) return reject(err) // 失败 resolve(dataStr) //成功 }) })}// getFile 方法的调用过程getFile('./files/1.txt').then(成功的回调函数， 失败的回调函数) async/await什么是 async/awaitasync/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作。在 async/await 出 现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。示例代码如下： 123456789101112thenFs.readFile('./files/1.txt','utf8') .then((r1) =&gt;{ console.log(r1) return thenFs.readFile('./files/2.txt', utf8') }) .then((r2) =&gt;{ console.log(r2) return thenFs.readFile('.lfiles/3.txt', 'utf8' ) }) .then((r3)=&gt; { console.log(r3) }) .then 链式调用的优点：解决了回调地狱的问题 .then 链式调用的缺点：代码冗余、阅读性差、不易理解 async/await 的基本使用使用 async/await 简化 Promise 异步操作的示例代码如下： 12345678910111213import thenFs from 'then-fs'// 按照顺序读取文件 1.2.3 的内容async function getAllFile() { const r1 = await thenFs.readFile('./files/1.txt','utf8') console.log(r1) const r2 = await thenFs.readFile('./files/2.txt','utf8') console.log(r2) const r3 = await thenFs.readFile('./files/3.txt','utf8') console.log(r3)}getAllFile() async/await 的使用注意事项 如果在 function 中使用了 await，则 function 必须被 async 修饰 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行 123456789101112console.log('A')async function getAllFile() { console.log('B') const r1 = await thenFs.readFile('./files/1.txt','utf8') const r2 = await thenFs.readFile('./files/2.txt','utf8') const r3 = await thenFs.readFile('./files/3.txt','utf8') console.log(r1, r2, r3) console.log('D')}jsgetAllFile()console.log('C') 123456// 最终输出的顺序ABc111 222 333D EventLoopJavaScript 是单线程的语言JavaScript 是一门单线程执行的编程语言。也就是说，同一时间只能做一件事情。 单线程执行任务队列的问题： 如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题。 同步任务和异步任务为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类： ① 同步任务（synchronous） 又叫做非耗时任务，指的是在主线程上排队执行的那些任务 只有前一个任务执行完毕，才能执行后一个任务 ② 异步任务（asynchronous） 又叫做耗时任务，异步任务由 JavaScript 委托给宿主环境进行执行 当异步任务执行完成后，会通知 JavaScript 主线程执行异步任务的回调函数 同步任务由 JavaScript 主线程次序执行 异步任务委托给宿主环境执行 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行 JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，按次序执行 JavaScript 主线程不断重复上面的第 4 步 EventLoop 的基本概念JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。 结合 EventLoop 分析输出的顺序12345678910import thenFs from 'then-fs'console.log('A')thenFs.readFile('./files/1.txt', 'utf8').then(dataStr =&gt; { console.log('B')})setTimeout(() =&gt; { console.log('C')}, 0)console.log('D') 正确的输出结果：ADCB。其中： A 和 D 属于同步任务。会根据代码的先后顺序依次被执行 C 和 B 属于异步任务。它们的回调函数会被加入到任务队列中，等待主线程空闲时再执行 宏任务和微任务 什么是宏任务和微任务 JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是： ① 宏任务（macrotask） 异步 Ajax 请求、 setTimeout、setInterval、 文件操作 其它宏任务 ② 微任务（microtask） Promise.then、.catch 和 .finally process.nextTick 其它微任务 宏任务和微任务的执行顺序每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务。 分析以下代码输出的顺序123456789101112setTimeout( function () { console.log('1'))new Promise( function (resolve) { console.log('2') resolve()}).then( function () { console.log('3')}) console.log('4') 正确的输出顺序是：2431 分析： ① 先执行所有的同步任务： 执行第 6 行、第 12 行代码 ② 再执行微任务： 执行第 9 行代码 ③ 再执行下一个宏任务： 执行第 2 行代码 经典面试题123456789101112131415161718192021222324252627console.log('1') setTimeout(function() { console.log('2') new Promise(function(resolve) { console.log('3') resolve() }).then(function () { console.log('4')}new Promise(function(resolve) { console.log('5') resolve()}).then(function() { console.log('6') })setTimeout(function() { console.log('7') new Promise(function(resolve) { console.log('8') resolve() }).then(function() { console.log('9') })}) 正确的输出顺序是：156234789","link":"/2022/08/16/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"},{"title":"Vue2","text":"vue 简介什么是 vue官方概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架。 vue 的特性vue 框架的特性，主要体现在如下两方面： 数据驱动视图 双向数据绑定 数据驱动视图在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。 好处：当页面数据发生变化时，页面会自动重新渲染！ 注意：数据驱动视图是单向的数据绑定。 双向数据绑定在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源 中。示意图如下： 好处：开发者不再需要手动操作 DOM 元素，来获取表单元素最新的值！ MVVMMVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM 指的是 Model、View 和 ViewModel， 它把每个 HTML 页面都拆分成了这三个部分，如图所示： Model 表示当前页面渲染时所依赖的数据源。 View 表示当前页面所渲染的 DOM 结构。 ViewModel 表示 vue 的实例，它是 MVVM 的核心。 MVVM 的工作原理ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。 当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构 当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中 vue 的基本使用基本使用步骤① 导入 vue.js 的 script 脚本文件 ② 在页面中声明一个将要被 vue 所控制的 DOM 区域 ③ 创建 vm 实例对象（vue 实例对象） 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Vue 控制下面的 div ，帮我们把数据填充到 div 内部 --&gt; &lt;div id=&quot;app&quot;&gt;{{ username }}&lt;/div&gt; &lt;!-- 导入 Vue 的库文件 --&gt; &lt;script src=&quot;./vue-2.6.12.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 创建 Vue 的实例对象 const vm = new Vue({ // el 属性固定写法，当前 vm 实例要控制页面的哪个区域，接收一个选择器 el: '#app', // data 对象是要渲染到页面上的数据 data: { username: 'zhangsan' } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue 的调试工具安装 vue-devtools 调试工具vue 官方提供的 vue-devtools 调试工具，能够方便开发者对 vue 项目进行调试与开发。 Chrome 浏览器在线安装 vue-devtools ： https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd FireFox 浏览器在线安装 vue-devtools ： https://addons.mozilla.org/zh-CN/firefox/addon/vue-js-devtools/ 配置 Chrome 浏览器中的 vue-devtools点击 Chrome 浏览器右上角的 三个点的自定义及控制按钮，更多工具 -&gt; 扩展程序 -&gt; Vue.js devtools 详细信息，并勾选允许访问文件网址的选项。 使用 vue-devtools 调试 vue 页面在浏览器中访问一个使用了 vue 的页面，打开浏览器的开发者工具，切换到 Vue 面板，即可使用 vue-devtools 调试当前的页面。 vue 的指令与过滤器指令的概念指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。 vue 中的指令按照不同的用途可以分为如下 6 大类： ​ 指令的概念 指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。 vue 中的指令按照不同的用途可以分为如下 6 大类： ① 内容渲染指令 ② 属性绑定指令 ③ 事件绑定指令 ④ 双向绑定指令 ⑤ 条件渲染指令 ⑥ 列表渲染指令 内容渲染指令内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个： v-text &lt;!–swig￼105–&gt; v-html v-text用法示例： 12345&lt;!-- 把username对应的值，渲染到第一个p标签中 --&gt;&lt;p v-text=&quot;username&quot;&gt;&lt;/p&gt;&lt;!-- 把gender 对应的值，渲染到第二个p标签中 --&gt;&lt;!-- 注意:第二个p标签中，默认的文本“性别”会被gender 的值覆盖掉 --&gt;&lt;p v-text=&quot;gender&quot;&gt;性别&lt;/p&gt; 注意：v-text 指令会覆盖元素内默认的值。 &lt;!–swig￼106–&gt; 语法vue 提供的 {{ }} 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 {{ }} 语法的专业名称是插值表达式（英文名为：Mustache）。 1234&lt;!-- 使用 {{ }} 插值表达式，将对应的值渲染到元素的内容节点中，--&gt;&lt;!-- 同时保留元素自身的默认值 --&gt;&lt;p&gt;姓名: {{ username }}&lt;/p&gt;&lt;p&gt;性别: {{ gender }}&lt;/p&gt; 注意：相对于 v-text 指令来说，插值表达式在开发中更常用一些！因为它不会覆盖元素中默认的文本内容。 v-htmlv-text 指令和插值表达式只能渲染纯文本内容。如果要把包含 HTML 标签的字符串渲染为页面的 HTML 元素，则需要用到 v-html 这个指令： 123&lt;!--假设data 中定义了名为 discription 的数据，数据的值为包含下面HTML标签的字符串: --&gt;&lt;!-- '&lt;h5 style=&quot;color: red;&quot;&gt;学习vue.js课程。&lt;/h5&gt;' --&gt;&lt;p v-html=&quot;discription&quot;&gt;&lt;/p&gt; 属性绑定指令如果需要为元素的属性动态绑定属性值，则需要用到 v-bind 属性绑定指令。用法示例如下： 1234567891011&lt;!--假设有如下的 data数据:data: { inputValue: '请输入内容'， imgSrc: 'https: //cn.vuejs.org/images/logo.png'}--&gt;&lt;!--使用v-bind指令，为input 的 placeholder动态绑定属性值--&gt;&lt;input type=&quot;text&quot; v-bind:placeholder=&quot;inputValue&quot; /&gt;&lt;br /&gt;&lt;!--使用v-bind 指令，为 img 的 src动态绑定属性值--&gt;&lt;img v-bind:src=&quot;imgSrc&quot; alt=&quot;&quot;/&gt; 由于 v-bind 指令在开发中使用频率非常高，因此，vue 官方为其提供了简写形式（简写为英文的 : ）。 12345&lt;!--使用v-bind指令，为input 的 placeholder动态绑定属性值--&gt;&lt;input type=&quot;text&quot; :placeholder=&quot;inputValue&quot; /&gt;&lt;br /&gt;&lt;!--使用v-bind 指令，为 img 的 src动态绑定属性值--&gt;&lt;img :src=&quot;imgSrc&quot; alt=&quot;&quot;/&gt; 使用 Javascript 表达式在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算，例如： 123456{{ number + 1 }}{{ ok ? 'YES’ : 'NO’ }}{{ message.split('').reverse().join('') }}&lt;!-- 字符串 list- 外面需要加单引号 --&gt;&lt;div :id=&quot;'list-' + id&quot;&gt;&lt;/div&gt; 事件绑定指令vue 提供了 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听。语法格式如下： 123&lt;h3&gt;count 的值为: {{ count }}&lt;/h3&gt;&lt;!--语法格式为 v-on:事件名称=&quot;事件处理函数的名称&quot;--&gt;&lt;button v-on:click=&quot;addCount&quot;&gt;+1&lt;/button&gt; 通过 v-on 绑定的事件处理函数，需要在 methods 节点中进行声明： 1234567891011121314151617const vm = new Vue({ // el 属性固定写法，当前 vm 实例要控制页面的哪个区域，接收一个选择器 el: '#app', // data 对象是要渲染到页面上的数据 data: { count: 0 }, // v-on绑定的事件处理函数,需要声明在 methods 节点中 method: { add() { // this表示当前 new 出来的 vm 实例对象， // 通过 this 可以访问到 data 中的数据 this.count += 1; } }}) 由于 v-on 指令在开发中使用频率非常高，因此，vue 官方为其提供了简写形式（简写为英文的 @ ）。 1&lt;button @click=&quot;addCount&quot;&gt;+1&lt;/button&gt; 事件参数对象在原生的 DOM 事件绑定中，可以在事件处理函数的形参处，接收事件参数对象 event。同理，在 v-on 指令 （简写为 @ ）所绑定的事件处理函数中，同样可以接收到事件参数对象 event，示例代码如下： 12345678910&lt;h3&gt;count 的值为: {{ count }}&lt;/h3&gt;&lt;button v-on:click=&quot;addCount&quot;&gt;+1&lt;/button&gt;// ------------------分割线------------------methods: { addCount(e) { // 接收事件参数对象 event，简写为e const nowBgColor = e.target.style.backgroundColor e.target.style.backgroundColor = nowBgColor === 'red' ? '' : 'red' this.count += 1 }} 绑定事件并传参在使用 v-on 指令绑定事件时，可以使用 ( ) 进行传参，示例代码如下： 123456789&lt;h3&gt;count的值为: {{count}}&lt;/h3&gt;&lt;button @click=&quot;addNewCount(2)&quot;&gt;+2&lt;/button&gt;// ----------分割线---------methods: { //在形参处用step接收传递过来的参数值 addNewCount(step) { this.count += step }} $event$event 是 vue 提供的特殊变量，用来表示原生的事件参数对象 event。$event 可以解决事件参数对象 event 被覆盖的问题。示例用法如下： 1234567891011&lt;h3&gt;count的值为: {{count}}&lt;/h3&gt;&lt;button @click=&quot;addNewCount(2，$event)&quot;&gt;+2&lt;/button&gt;// ----------------------分割线------------------methods: { //在形参处用e接收传递过来的原生事件参数对象$event addNewCount(step，e) { const nowBgColor = e.target.style.backgroundColor e.target.style.backgroundColor = nowBgColor === 'cyan' ? '' : 'cyan' this.count t= step }} 事件修饰符在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。因此，vue 提供了事件修饰符的概念，来辅助程序员更方便的对事件的触发进行控制。常用的 5 个事件修饰符如下： 事件修饰符 说明 .prevent 阻止默认行为（例如：阻止 a 连接的跳转、阻止表单的提交等） .stop 阻止事件冒泡 .capture 以捕获模式触发当前的事件处理函数 .once 绑定的事件只触发1次 .self 只有在 event.target 是当前元素自身时触发事件处理函数 语法格式如下： 12&lt;!-- 触发 click 点击事件时，阻止 a 链接的默认跳转行为--&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;onLinkClick&quot;&gt;百度首页&lt;/a&gt; 按键修饰符在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符，例如： 1234&lt;!-- 只有在'key'是'Enter'时调用 vm.submit()--&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;&lt;!-- 只有在‘key'是‘Esc'时调 vm.clearInput() --&gt;&lt;input @keyup.esc=&quot;clearInput&quot;&gt; 双向绑定指令vue 提供了 v-model 双向数据绑定指令，用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据。 12345678910&lt;p&gt;用户名是: {{ username }}&lt;/p&gt;&lt;input type=&quot;text&quot; v-model=&quot;username&quot;/&gt;&lt;p&gt;选中的省份是: {{ province }}&lt;/p&gt;&lt;select v-model=&quot;province&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;河北&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;河南&lt;/option&gt;&lt;/select&gt; v-model 指令的修饰符为了方便对用户输入的内容进行处理，vue 为 v-model 指令提供了 3 个修饰符，分别是： 修饰符 作用 示例 .number 自动将用户的输入值转为数值类型 .trim 自动过滤用户输入的首尾空白字符 .lazy 在 “ change ” 时而非 “ input ” 时更新 示例用法如下： 123&lt;input type=&quot;text&quot; v-model.number=&quot;n1&quot;&gt; +&lt;input type=&quot;text&quot; v-model.number=&quot;n2&quot;&gt; =&lt;span&gt;{{ n1 + n2 }}&lt;/span&gt; 条件渲染指令条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。条件渲染指令有如下两个，分别是： v-if v-show 示例用法如下： 1234567&lt;p v-if=&quot;flag&quot;&gt;这是被 v-if 控制的元素&lt;/p&gt;&lt;p v-show=&quot;flag&quot;&gt;这是被 v-show 控制的元素&lt;/p&gt;//------------- 分隔线 --------------data: { // 如果 flag 为 true，则显示被控制的元素；如果为 false 则隐藏被控制的元素 flag: false} v-if 和 v-show 的区别实现原理不同： v-if 指令会动态地创建或移除 DOM 元素，从而控制元素在页面上的显示与隐藏； v-show 指令会动态为元素添加或移除 style=&quot;display: none;&quot; 样式，从而控制元素的显示与隐藏； 性能消耗不同： v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此： 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好（实际用的多） v-else 和 v-else-if注意：v-else 指令和 v-else-if 指令必须配合 v-if 指令一起使用，否则它将不会被识别！ 1234&lt;div v-if=&quot;type === 'A'&quot;&gt;优秀&lt;/div&gt;&lt;div v-else-if=&quot;type === 'B'&quot;&gt;良好&lt;/div&gt;&lt;div v-else-if=&quot;type === 'C'&quot;&gt;一般&lt;/div&gt;&lt;div v-else&gt;差&lt;/div&gt; 列表渲染指令vue 提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使 用 item in items 形式的特殊语法，其中： items 是待循环的数组 item 是被循环的每一项 v-for 指令还支持一个可选的第二个参数，即当前项的索引。语法格式为 (item, index) in items 123456789101112131415161718192021222324252627&lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;th&gt;索引&lt;/th&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 官方建议：只要用到了 v-for 指令，那么一定要绑定一个 :key 属性 --&gt; &lt;!-- 而且，尽量把 id 作为 key 的值 --&gt; &lt;!-- 官方对 key 的值类型，是有要求的：字符串或数字类型 --&gt; &lt;!-- key 的值是千万不能重复的，否则会终端报错：Duplicate keys detected --&gt; &lt;tr v-for=&quot;(item, index) in list&quot;&gt; &lt;td&gt;{{ index }}&lt;/td&gt; &lt;td&gt;{{ item.id }}&lt;/td&gt; &lt;td&gt;{{ item.name }}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;data: { list: [ { id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' }, { id: 4, name: '张三' }, ] } 注意：v-for 指令中的 item 项和 index 索引都是形参，可以根据需要进行重命名。例如 (user, i) in userlist 使用 key 维护列表的状态当列表的数据变化时，默认情况下，vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能。但这种 默认的性能优化策略，会导致有状态的列表无法被正确更新。 为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而在保证有状态的列表被正确更新的前提下，提升渲 染的性能。此时，需要为每项提供一个唯一的 key 属性： 1&lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt; key 的注意事项① key 的值只能是字符串或数字类型 ② key 的值必须具有唯一性（即：key 的值不能重复） ③ 建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性） ④ 使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性） ⑤ 建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱） 过滤器过滤器（Filters）是 vue 为开发者提供的功能，常用于文本的格式化。过滤器可以用在两个地方：插值表达式 和 v-bind 属性绑定。 过滤器应该被添加在 JavaScript 表达式的尾部，由 “管道符” 进行调用，示例代码如下： 12345&lt;!-- 在双花括号中通过“管道符&quot;调用 capitalize 过滤器，对 message 的值进行格式化 --&gt;&lt;p&gt;{{ message | capitalize }}&lt;/p&gt;&lt;!-- 在 v-bind 中通过“管道符&quot;调用 formatId 过滤器，对 rawId 的值进行格式化 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 定义过滤器在创建 vue 实例期间，可以在 filters 节点中定义过滤器，示例代码如下： 1234567891011const mv = new Vue({ el: '#app', data: { message: 'hello vue.js' }, filters: { // 在 filters 节点下定义 &quot;过滤器&quot; capitalize(str){ // 把首字母转为大写的过滤器 return str.charAt(0).toUpperCase() + str.slice(1) } }}) 私有过滤器和全局过滤器在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。 如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器： 1234567// 全局过滤器 – 独立于每个 vm 实例之外// Vue.filter() 方法接收两个参数:// 第1个参数，是全局过滤器的&quot;名字&quot;// 第2个参数，是全局过滤器的&quot;处理函数&quot;Vue.filter('capitalize', (str) =&gt;{ return str.charAt(O).toUpperCase() + str.slice(1) }) 连续调用多个过滤器过滤器可以串联地进行调用，例如： 1234&lt;!-- 把 message 的值，交给 filterA 进行处理 --&gt;&lt;!-- 把 filterA 处理的结果，再交给 filterB 进行处理 --&gt;&lt;!-- 最终把 filterB 处理的结果，作为最终的值渲染到页面上 --&gt;{{ message | filterA | filterB }} 过滤器传参过滤器的本质是 JavaScript 函数，因此可以接收参数，格式如下： 123456789&lt;!-- arg1 和 arg2是传递给 filterA 的参数 --&gt;&lt;p&gt;{{ message | filterA(arg1, arg2) }}&lt;/p&gt;// 过滤器处理函数的形参列表中:// 第一个参数:永远都是&quot;管道符“前面待处理的值// 从第二个参数开始，才是调用过滤器时传递过来的 arg1 和 arg2 参数Vue.filter('filterA' , (msg, arg1, arg2) =&gt;{ //过滤器的代码逻辑...}) 注意： 过滤器仅在 vue 2.x 和 1.x 中受支持，在 vue 3.x 的版本中剔除了过滤器相关的功能。 如果项目已经升级到了 3.x 版本的 vue，官方建议使用计算属性或方法代替被剔除的过滤器功能。 watch 侦听器什么是 watch 侦听器watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。 语法格式如下： 1234567891011const vm = new Vue({ el: '#app', data: { username: '' }， watch: { // 监听 username 值的变化 // newVal是&quot;变化后的新值&quot;，oldVal是&quot;变化之前的旧值&quot; username(newVal, oldVal) { console.log(newVal,oldVal) } }}) 使用 watch 检测用户名是否可用jQuery 监听1234567891011121314151617181920&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;const vm = new Vue({ el: '#app', data: { username: 'admin' }, // 所有的侦听器，都应该被定义到 watch 节点下 watch: { // 侦听器本质上是一个函数，要监视哪个数据的变化，就把数据名作为方法名即可 // 新值在前，旧值在后 username(newVal) { if (newVal === '') return // 1. 调用 jQuery 中的 Ajax 发起请求，判断 newVal 是否被占用 $.get('https://www.escook.cn/api/finduser/' + newVal, function (result) { console.log(result) }) } } }) axios 监听axios 是一个专注于网络请求的库！ 监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用： 12345678910&lt;script src=&quot;./lib/axios.js&quot;&gt;&lt;/script&gt;watch: { // 监听 username 值的变化 async username(newVal) { if (newVal === '') return // 使用 axios 发起请求，判断用户名是否可用 const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal) console.log(res)} } immediate 选项默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使 用 immediate 选项。示例代码如下： 123456789101112watch: { username: { // handler 是固定写法，表示当 username 的值变化时，自动调用 handler 处理函数 handler: async function (newVal) { if (newVal === '') return const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal) console.log(res) }, // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器 immediate: true } } deep 选项如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 选 项，代码示例如下： 1234567891011121314const vm = new Vue({ el: '#app ', data: { info: { username: 'admin'} }, watch: { info: { handler(newVal) { console.log(newVal.username) }， deep: true } }}) 监听对象单个属性的变化如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器。与 deep 作用一样 12345678910111213const vm = new Vue({ el: '#app ', data: { info: { username: 'admin' } }, watch: { 'info.username': { handler(newVal) { console.log(newVal.username) } } }}) axios 发送 GET 和POST请求123456789101112131415161718192021222324252627document.querySelector('#btnPost').addEventListener('click', async function () { // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！ // await 只能用在被 async “修饰”的方法中 const { data } = await axios({ method: 'POST', url: 'http://www.liulongbin.top:3006/api/post', data: { name: 'zs', age: 20 } }) console.log(data)})document.querySelector('#btnGet').addEventListener('click', async function () { // 解构赋值的时候，使用 : 进行重命名 // 1. 调用 axios 之后，使用 async/await 进行简化 // 2. 使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来 // 3. 把解构出来的 data 属性，使用 冒号 进行重命名，一般都重命名为 { data: res } const { data: res } = await axios({ method: 'GET', url: 'http://www.liulongbin.top:3006/api/getbooks' }) console.log(res.data)}) 或直接发送请求 1234567891011121314151617document.querySelector('#btnGET').addEventListener('click', async function () { /* axios.get('url地址', { // GET 参数 params: {} }) */ const { data: res } = await axios.get('http://www.liulongbin.top:3006/api/getbooks', { params: { id: 1 } }) console.log(res)})document.querySelector('#btnPOST').addEventListener('click', async function () { // axios.post('url', { /* POST 请求体数据 */ }) const { data: res } = await axios.post('http://www.liulongbin.top:3006/api/post', { name: 'zs', gender: '女' }) console.log(res)}) 计算属性什么是计算属性计算属性指的是通过一系列运算之后，最终得到一个属性值。 这个动态计算出来的属性值可以被模板结构或 methods 方法使用。示例代码如下： 12345678910111213141516171819202122232425262728293031&lt;div class=&quot;box&quot; :style=&quot;{ backgroundColor: rgb }&quot;&gt; {{ rgb }} &lt;/div&gt;&lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;var vm = new Vue({ el: '#app', data: { // 红色 r: 0, // 绿色 g: 0, // 蓝色 b: 0 }, methods: { // 点击按钮，在终端显示最新的颜色 show() { console.log(this.rgb) } }, // 所有的计算属性，都要定义到 computed 节点之下 // 计算属性在定义的时候，要定义成“方法格式” computed: { // rgb 作为一个计算属性，被定义成了方法格式， // 最终，在这个方法中，要返回一个生成好的 rgb(x,x,x) 的字符串 rgb() { return `rgb(${this.r}, ${this.g}, ${this.b})` } }}); 计算属性的特点① 虽然计算属性在声明的时候被定义为方法，但是计算属性的本质是一个属性 ② 计算属性会缓存计算的结果，只有计算属性依赖的数据变化时，才会重新进行运算 vue-cli单页面应用程序单页面应用程序（英文名：Single Page Application）简称 SPA，顾名思义，指的是一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能与交互都在这唯一的一个页面内完成。 什么是 vue-clivue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程。 引用自 vue-cli 官网上的一句话： 程序员可以专注在撰写应用上，而不必花好几天去纠结 webpack 配置的问题。 中文官网：https://cli.vuejs.org/zh/ 安装和使用 vue-clivue-cli 是 npm 上的一个全局包，使用 npm install 命令，即可方便的把它安装到自己的电脑上： 1npm install -g @vue/cli 基于 vue-cli 快速生成工程化的 Vue 项目： 1vue create 项目的名称(英文名) vue 项目的运行流程在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。 其中： ① App.vue 用来编写待渲染的模板结构 ② index.html 中需要预留一个 el 区域 ③ main.js 把 App.vue 渲染到了 index.html 所预留的区域中 vue 组件什么是组件化开发组件化开发指的是：根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护。 vue 中的组件化开发vue 是一个支持组件化开发的前端框架。 vue 中规定：组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件。 vue 组件的三个组成部分每个 .vue 组件都由 3 部分构成，分别是： template -&gt; 组件的模板结构 script -&gt; 组件的 JavaScript 行为 style -&gt; 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。 templatevue 规定：每个组件对应的模板结构，需要定义到 &lt;template&gt; 节点中。 123456&lt;template&gt; &lt;!-- 当前组件的 DOM 结构 --&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt; 注意： template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素 template 中只能包含唯一的根节点 scriptvue 规定：开发者可以在 &lt;script&gt; 节点中封装组件的 JavaScript 业务逻辑。&lt;script&gt; 节点的基本结构如下： 1234567891011121314&lt;script&gt;// 今后，组件相关的 data 数据、methods方法等，// 都需要定义到export default所导出的对象中。export default{ data() { return { name: 'zs' } }, methods: { }}&lt;/script&gt; vue 规定：.vue 组件中的 data 必须是一个函数，不能直接指向一个数据对象。 stylevue 规定：组件内的 &lt;style&gt; 节点是可选的，开发者可以在 &lt;style&gt; 节点中编写样式美化当前组件的 UI 结构。 在 &lt;style&gt; 标签上添加 lang=&quot;less&quot; 属性，即可使用 less 语法编写组件的样式： 12345678&lt;style lang=&quot;less&quot;&gt; h1 { font-weight: normal; span { color: red; } }&lt;/style&gt; 组件之间的父子关系组件在被封装好之后，彼此之间是相互独立的，不存在父子关系 在使用组件的时候，根据彼此的嵌套关系，形成了父子关系、兄弟关系 使用组件的三个步骤步骤1：使用 import 语法导入需要的组件 1import Left from '@/components/Left.vue' 步骤2：使用 components 节点注册组件/导入需要全局注册的组件import Count from ‘@/components/Count.vue’l/参数1:字符串格式，表示组件的”注册名称”1/参数2:需要被全局注册的那个组件vue.component( ‘ MyCount’ , Count) 1234567export defalut { // 通过 components 注册的是私有子组件 // 不能在其他组件中使用 components: { Left }} 步骤3：以标签形式使用刚才注册的组件 123&lt;div&gt; &lt;Left&gt;&lt;/Left&gt;&lt;/div&gt; 注册全局组件在 vue 项目的 main.js 入口文件中，通过 Vue.component() 方法，可以注册全局组件。示例代码如下： 123456//导入需要全局注册的组件import Count from '@/components/Count.vue'// 参数1: 字符串格式，表示组件的&quot;注册名称&quot;// 参数2: 需要被全局注册的那个组件Vue.component('MyCount' , Count) 组件的 propsprops 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性！ 它的语法格式如下： 123456789export default { // 组件的自定义属性 props:['自定义属性A', '自定义属性B', '其它自定义属性... '], // 组件的私有数据 data() { return { } }} props 是只读的vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。否则会直接报错。 要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！ 123456props: [ 'init'], data() { return { count: this.init // 把 this.init 的值转存到 count }} props 的 default 默认值在声明自定义属性时，可以通过 default 来定义属性的默认值。示例代码如下： 12345678export default { props: { init: { //用 default 属性定义属性的默认值 default: 0 } } } props 的 type 值类型在声明自定义属性时，可以通过 type 来定义属性的值类型。类型不匹配会报错。示例代码如下： 1234567891011export default { props : { init: { // 用 default 属性定义属性的默认值 default: 0， // 用 type 属性定义属性的值类型， // 如果传递过来的值不符合此类型，则会在终端报错 type: Number } }} props 的 required 必填项在声明自定义属性时，可以通过 required 选项，将属性设置为必填项，强制用户必须传递属性的值。示例代码如下： 12345678910export default { props: { init: { // 值类型为 Number 数字 type: Number , // 必填项校验 required: true } }} 组件之间的样式冲突问题默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。 导致组件之间样式冲突的根本原因是： 单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的 每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素 如何解决组件样式冲突的问题为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域，示例代码如下： 12345678910111213&lt;template&gt; &lt;div class=&quot;container&quot; data-v-001&gt; &lt;h3 data-v-001&gt;轮播图组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; /* 通过中括号&quot;属性选择器&quot;，来防止组件之间的&quot;样式冲突问题&quot;， 因为每个组件分配的自定义属性是&quot;唯一的&quot; */ .container[data-v-0001] { border: 1px solid red; }&lt;/style&gt; style 节点的 scoped 属性为了提高开发效率和开发体验，vue 为 style 节点提供了 scoped 属性，从而防止组件之间的样式冲突问题： 1234567891011121314&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;轮播图组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; /* style 节点的 scoped 属性，用来自动为每个组件分配唯一的”自定义属性&quot;， 并自动为当前组件的 DOM 标签和 style 样式应用这个自定义属性，防止组件的样式冲突问题。 作用同上 */ .container { border: 1px solid red; }&lt;/style&gt; /deep/ 样式穿透如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。 123456789&lt;style lang=&quot;less&quot; scoped&gt; .title { color: blue; /* 不加 /deep/ 时，生成的选择器格式为 .title[data-v-052242de] */ } /deep/ .title { color: blue; /* 加上 /deep/ 时，生成的选择器格式为 [data-v-052242de] .title */ }&lt;/style&gt; 组件的生命周期生命周期 &amp; 生命周期函数生命周期（Life Cycle）是指一个组件从创建 -&gt; 运行 -&gt; 销毁的整个阶段，强调的是一个时间段。 生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。 注意：生命周期强调的是时间段，生命周期函数强调的是时间点。 组件生命周期函数的分类组件生命周期函数的分类 组件生命周期的第 1 个阶段 （ 组件创建阶段 ）: new Vue() -&gt; beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted 组件生命周期的第 2 个阶段 ( 组件运行阶段 ) ： beforeUpdate -&gt; updated 组件生命周期的第 3 个阶段 ( 组件销毁阶段 ) : beforeDestroy -&gt; destroyed 生命周期图示 组件之间的数据共享组件之间的关系在项目开发中，组件之间的最常见的关系分为如下两种： 父子关系 兄弟关系 父子组件之间的数据共享父子组件之间的数据共享又分为： 父 -&gt; 子 共享数据 子 -&gt; 父 共享数据 父组件向子组件共享数据父组件向子组件共享数据需要使用自定义属性。示例代码如下： 123456789// 父组件&lt;Son :msg=&quot;message&quot; :user=&quot;userinfo&quot;&gt;&lt;/Son&gt;data() { return { message: &quot;hello vue.js ', userinfo: { name: 'zs', age: 20 } }} 12345678910// 子组件&lt;template&gt; &lt;div&gt; &lt;h5&gt;Son组件&lt;/h5&gt; &lt;p&gt;父组件传递过来的 msg 值是: {{ msg }}&lt;/p&gt; &lt;p&gt;父组件传递过来的 user 值是: {{ user }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;props: ['msg', 'user'] 子组件向父组件共享数据子组件向父组件共享数据使用自定义事件。示例代码如下： 123456789101112// 子组件export default { data() { return { count: o }}, methods: { add() { this.count += 1 // 修改数据时，通过$emit() 触发自定义事件 this.$emit('numchange', this.count) } }} 12345678910111213// 父组件&lt;Son @numchange=&quot;getNewCount&quot;&lt;/Son&gt;export default { data() { return { countFromSon: 0 } }, methods: { getNewCount(val) { this.countFromSon = val } }} 兄弟组件之间的数据共享在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus。 1234// eventBus.jsimport Vue from 'vue'// 向外共享 Vue 的实例对象export default new Vue() 12345678910111213// 兄弟组件A（数据发送方)import bus from './eventBus.js'export default { data() { return { msg: &quot;hello&quot; } }, methods: { addMsg() { bus.$emit('share', this.msg) } }} 12345678910111213// 兄弟组件C（数据接收方)import bus from './ eventBus.js'export default { data() { return { msgFromLeft: ' '} }, created() { bus.$on('share', val =&gt; { this.msgFromLeft = val }) }} EventBus 的使用步骤 创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象 在数据发送方，调用 bus.$emit('事件名称', 要发送的数据) 方法触发自定义事件 在数据接收方，调用 bus.$on('事件名称', 事件处理函数) 方法注册一个自定义事件 ref 引用什么是 ref 引用ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用。 每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下， 组件的 $refs 指向一个空对象。 1234567891011&lt;template&gt; &lt;div&gt; &lt;h3&gt;MyRef组件&lt;/h3&gt; &lt;button @click=&quot;getRef&quot;&gt;获取 $refs 引用&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default { methods: { getRef() { console.log(this) } // this是当前组件的实例对象，this.$refs默认指向空对象 }} 使用 ref 引用 DOM 元素如果想要使用 ref 引用页面上的 DOM 元素，则可以按照如下的方式进行操作： 123456789101112&lt;!-- 使用ref属性，为对应的DOM添加引用名称 --&gt;&lt;h3 ref=&quot;myh3&quot;&gt;MyRef 组件&lt;/h3&gt;&lt;button @click=&quot;getRef&quot;&gt;获取$refs 引用&lt;/button&gt;methods : { getRef() { // 通过 this.$refs.引用的名称可以获取到DOM元素的引用 console.log(this.$refs.myh3) // 操作DOM元素，把文本颜色改为红色 this.$refs.myh3.style.color = 'red' }，} 使用 ref 引用组件实例如果想要使用 ref 引用页面上的组件实例，则可以按照如下的方式进行操作： 123456789101112&lt;!--使用ref 属性，为对应的“组件&quot;添加引用名称--&gt;&lt;my-counter ref=&quot;counterRef&quot;&gt;&lt;/my-counter&gt;&lt;button @click=&quot;getRef&quot;&gt;获取$refs 引用&lt;/button&gt;methods : { getRef() { // 通过 this.$refs.引用的名称，可以引用组件的实例 console.log(this.$refs.counterRef) // 引用到组件的实例之后，就可以调用组件上的 methods 方法 this.$refs.counterRef.add() },} 控制文本框和按钮的按需切换通过布尔值 inputVisible 来控制组件中的文本框与按钮的按需切换。以及文本框展示出来之后，让它立即获得焦点示例代码如下： 1234&lt;template&gt; &lt;input type=&quot;text&quot; v-if=&quot;inputVisible&quot; @blur=&quot;showButton&quot; ref=&quot;iptRef&quot;&gt; &lt;button v-else @click=&quot;showInput&quot;&gt;展示输入框&lt;/button&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627export default { data() { return { // 控制输入框和按钮的按需切换； // 默认值为 false，表示默认展示按钮，隐藏输入框 inputVisible: false } }, /* updated() { this.$refs.iptRef.focus() }, */ methods: { // 点击按钮，展示输入框 showInput() { // 1. 切换布尔值，把文本框展示出来 this.inputVisible = true // 2. 让展示出来的文本框，自动获取焦点，需要获取文本框的 DOM 引用 // nextTick是vue框架里面一个全局api。它是当前异步更新队列循环结束之后的回调函数。 this.$nextTick(() =&gt; { this.$refs.iptRef.focus() }) }, showButton() { this.inputVisible = false }, },} this.$nextTick(cb) 方法组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。通俗的理解是：等组件的DOM 更新完成之后，再执行 cb 回调函数。从而能保证 cb 回调函数可以操作到最新的 DOM 元素。 动态组件什么是动态组件动态组件指的是动态切换组件的显示与隐藏。 如何实现动态组件渲染vue 提供了一个内置的 &lt;component&gt; 组件，专门用来实现动态组件的渲染。示例代码如下： 1234567891011data() { // 1．当前要渲染的组件名称 return { comName: 'Left' }}&lt;!-- 2．通过is属性，动态指定要渲染的组件--&gt;&lt;component :is=&quot;comName&quot;&gt;&lt;/ component&gt;&lt;!-- 3．点击按钮，动态切换组件的名称--&gt;&lt;button @click=&quot;comName = 'Left'&quot;&gt;展示 Left 组件&lt;/button&gt;&lt;button @click=&quot;comName = 'Right'&quot;&gt;展示 Right 组件&lt;/button&gt; 使用 keep-alive 保持状态默认情况下，切换动态组件时无法保持组件的状态。此时可以使用 vue 内置的 &lt;keep-alive&gt; 组件保持动态组件的状态。示例代码如下： 123&lt;keep-alive&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; keep-alive 对应的生命周期函数当组件被缓存时，会自动触发组件的 deactivated 生命周期函数。 当组件被激活时，会自动触发组件的 activated 生命周期函数。 1234567export default { created() { console.log( '组件被创建了')}, destroyed() { console.log( '组件被销毁了')}， activated() { console.log( 'Left 组件被激活了!')}， deactivated() { console.log( 'Left 组件被缓存了!')}} keep-alive 的 include 属性include 属性用来指定：只有名称匹配的组件会被缓存。多个组件名之间使用英文的逗号分隔： 123&lt;keep-alive include=&quot;MyLeft,MyRight&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; exclude 属性用来指定：只有名称匹配的组件不会被缓存。 include 与 exclude 不能一起使用 插槽什么是插槽插槽（slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的 部分定义为插槽。 可以把插槽认为是组件封装期间，为用户预留的内容的占位符。 插槽的基础用法在封装组件时，可以通过 &lt;slot&gt; 元素定义插槽，从而为用户预留内容占位符。示例代码如下： 123456&lt;template&gt; &lt;p&gt;这是 MyCom1 组件的第1个p标签&lt;/p&gt; &lt;!--通过 slot标签，为用户预留内容占位符（插槽）--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt;这是 MyCom1 组件最后一个p标签&lt;/p&gt;&lt;/template&gt; 1234&lt;my-com-1&gt; &lt;!-- 在使用 MyCom1 组件时，为插槽指定具体的内容 --&gt; &lt;p&gt;~~~用户自定义的内容~~~&lt;/p&gt;&lt;/my-com-1&gt; 没有预留插槽的内容会被丢弃如果在封装组件时没有预留任何 &lt;slot&gt; 插槽，则用户提供的任何自定义内容都会被丢弃。示例代码如下： 12345 &lt;template&gt; &lt;p&gt;这是 MyCom1 组件的第1个p标签&lt;/p&gt; &lt;!--封装代码时，没有为用户预留内容占位符（插槽）--&gt; &lt;p&gt;这是 MyCom1 组件最后一个p标签&lt;/p&gt;&lt;/template&gt; 1234&lt;my-com-1&gt; &lt;!-- 用户自定义内容会被丢弃 --&gt; &lt;p&gt;~~~用户自定义的内容~~~&lt;/p&gt;&lt;/my-com-1&gt; 后备内容封装组件时，可以为预留的 &lt;slot&gt; 插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。示例代码如下： 12345&lt;template&gt; &lt;p&gt;这是 MyCom1 组件的第1个p标签&lt;/p&gt; &lt;slot&gt;这是后备内容&lt;lslot&gt; &lt;p&gt;这是 MyCom1 组件最后一个p标签&lt;/p&gt;&lt;/template&gt; 具名插槽如果在封装组件时需要预留多个插槽节点，则需要为每个 &lt;slot&gt; 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做 “具名插槽” 。示例代码如下： 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;!--页头放这里--&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!--主要内容放这里--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;!--页脚放这里--&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 为具名插槽提供内容在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。示例代码如下： 12345678910111213&lt;my-com-2&gt; &lt;template v-slot:header&gt; &lt;h1&gt;头部内容&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;文章内容&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;落款:XXX&lt;/p&gt; &lt;/template&gt;&lt;/my-com-2&gt; 具名插槽的简写形式 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header可以被重写为 #header： 12345678910111213&lt;my-com-2&gt; &lt;template #header&gt; &lt;h1&gt;头部内容&lt;/h1&gt; &lt;/template&gt; &lt;template #default&gt; &lt;p&gt;文章内容&lt;/p&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;p&gt;落款:XXX&lt;/p&gt; &lt;/template&gt;&lt;/my-com-2&gt; 作用域插槽在封装组件的过程中，可以为预留的 &lt;slot&gt; 插槽绑定 props 数据，这种带有 props 数据的 叫做 “作用域插槽” 。示例代码如下： 1234&lt;tbody&gt; &lt;!--下面的 slot 是一个作用域插槽--&gt; &lt;slot v-for=&quot;item in list&quot; :user=&quot;item&quot;&gt;&lt;/slot&gt;&lt;/tbody&gt; 使用作用域插槽可以使用 v-slot: 的形式，接收作用域插槽对外提供的数据。示例代码如下： 123456789&lt;my-com-3&gt; &lt;!-- 1．接收作用域插槽对外提供的数据--&gt; &lt;template v-slot: default=&quot;scope&quot;&gt; &lt;tr&gt; &lt;!-- 2．使用作用域插槽的数据--&gt; &lt;td&gt;{{ scope }}&lt;/td&gt; &lt;/tr&gt; &lt;/template&gt;&lt;/my-com-3&gt; 解构插槽 Prop作用域插槽对外提供的数据对象，可以使用解构赋值简化数据的接收过程。示例代码如下： 1234567891011&lt;my-com-3&gt; &lt;!-- v-slot:可以简写成# --&gt; &lt;!-- 作用域插槽对外提供的数据对象，可以通过“解构赋值&quot;简化接收的过程 --&gt; &lt;template #default=&quot;{user}&quot;&gt; &lt;tr&gt; &lt;td&gt;{{user.id})&lt;/td&gt; &lt;td&gt;{{user.name}}&lt;/td&gt; &lt;td&gt;{{user.state}}&lt;/td&gt; &lt;/tr&gt; &lt;/template&gt;&lt;/my-com-3&gt; 自定义指令什么是自定义指令vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令。 自定义指令的分类vue 中的自定义指令分为两类，分别是： 私有自定义指令 全局自定义指令 私有自定义指令在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令。示例代码如下： 123456789directives: { color: { // 为绑定到的 HTML元素设置红色的文字 bind(el) { // 形参中的 el 是绑定了此指令的、原生的 DOM 对象 el.style.color = 'red' } }} 使用自定义指令在使用自定义指令时，需要加上 v- 前缀。示例代码如下： 123&lt;!--声明自定义指令时，指令的名字是 color --&gt;&lt;!--使用自定义指令时，需要加上v-指令前缀--&gt;&lt;h1 v-color&gt; App 组件&lt;/h1&gt; 为自定义指令动态绑定参数值在 template 结构中使用自定义指令时，可以通过等号（=）的方式，为当前指令动态绑定参数值： 12345678data() { return { color : 'red' // 定义 color颜色值 }}&lt;!--在使用指令时，动态为当前指令绑定参数值 color --&gt;&lt;h1 v-color=&quot;color&quot;&gt;App 组件&lt;/h1&gt; 通过 binding 获取指令的参数值在声明自定义指令时，可以通过形参中的第二个参数，来接收指令的参数值： 12345678directives: { color: { bind(el, binding) { //通过 binding对象的 .value属性，获取动态的参数值 el.style.color = binding.value } }} update 函数bind 函数只调用 1 次：当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。 update 函数会在每次 DOM 更新时被调用。示例代码如下： 123456789101112directives: { color: { // 当指令第一次被绑定到元素时被调用 bind(el, binding) { el.style.color = binding.value }, // 每次 DOM 更新时被调用 update(el, binding) { el.style.color = binding.value } }} 函数简写如果 bind 和update 函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式： 123456directives: { // 在insert和update 时，会触发相同的业务逻辑 color(el, binding) { el.style.color = binding.value }} 全局自定义指令全局共享的自定义指令需要通过“Vue.directive()”进行声明，示例代码如下： 12345//参数1:字符串，表示全局自定义指令的名字//参数2:对象，用来接收指令的参数值Vue.directive('color', function(el, binding) { el.style.color = binding.value} 了解 ESLint 常见的语法规则ESLint 提供了许多校验代码格式的语法规则，常见的语法规则列表如下： 序号 规则名称 规则约束/默认约束 1 quotes 默认：字符串需要使用单引号包裹 2 key-spacing 默认：对象的属性和值之间，需要有一个空格分割 3 comma-dangle 默认：对象或数组的末尾，不允许出现多余的逗号 4 no-multiple-empty-lines 不允许出现多个空行 5 no-trailing-spaces 不允许在行尾出现多余的空格 6 eol-last 默认：文件的末尾必须保留一个空行 7 spaced-comment 在注释中的//或/*后强制使用一致的间距 8 indent 强制一致的缩进 9 import/first import 导入模块的语句必须声明在文件的顶部 10 space-before-function-paren 方法的形参之前是否需要保留一个空格 详细的 ESLint 语法规则列表，请参考官方文档 https://eslint.org/docs/rules/ 前端路由的概念与原理什么是路由路由（英文：router）就是对应关系。 SPA 与前端路由SPA 指的是一个 web 网站只有唯一的一个 HTML 页面，所有组件的展示与切换都在这唯一的一个页面内完成。此时，不同组件之间的切换需要通过前端路由来实现。 结论：在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成！ 什么是前端路由通俗易懂的概念：Hash 地址与组件之间的对应关系。 前端路由的工作方式 用户点击了页面上的路由链接 导致了 URL 地址栏中的 Hash 值发生了变化 前端路由监听了到 Hash 地址的变化 前端路由把当前 Hash 地址对应的组件渲染到浏览器中 实现简易的前端路由步骤1：通过 &lt;component&gt; 标签，结合 comName 动态渲染组件。示例代码如下： 123456789101112&lt;!-- 通过is属性，指定要展示的组件的名称 --&gt;&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;export default { name: 'App ', data() { return { //要展示的组件的名称 comName: 'Home' } }} 步骤2：在 App.vue 组件中，为 &lt;a&gt; 链接添加对应的 hash 值： 123&lt;a href=&quot;#/home&quot;&gt;Home&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#/movie&quot;&gt;Movie&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#/about&quot;&gt;About&lt;/a&gt; 步骤3：在 created 生命周期函数中，监听浏览器地址栏中 hash 地址的变化，动态切换要展示的组件的名称： 123456789101112131415created() { window.onhashchange = () =&gt; { switch (location.hash){ case '#/home' : // 点击了&quot;首页&quot;的链接 this.comName = 'Home' break case '#/movie': // 点击了&quot;电影&quot;的链接 this.comName = 'Movie' break case '#/about ' : // 点击了&quot;关于&quot;的链接 this.comName = 'About' break } }} vue-router 的基本用法什么是 vue-routervue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。 vue-router 的官方文档地址：https://router.vuejs.org/zh/ vue-router 安装和配置的步骤 安装 vue-router 包 创建路由模块 导入并挂载路由模块 声明路由链接和占位符 在项目中安装 vue-router在 vue2 的项目中，安装 vue-router 的命令如下： 1npm i vue-router@3.5.2 -S 创建路由模块在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码： 123456789101112// 1．导入 Vue和 VueRouter 的包import Vue from 'vue'import VueRouter from 'vue-router'// 2．调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件vue.use(VueRouter)// 3．创建路由的实例对象const router = new VueRouter()// 4．向外共享路由的实例对象export default router 导入并挂载路由模块在 src/main.js 入口文件中，导入并挂载路由模块。示例代码如下： 123456789import Vue from 'vue'import App from '.lApp. vue'// 1．导入路由模块import router from '@/router'new Vue({ render: h =&gt; h(App), // 2．挂载路由模块,下面代码可简写为 router router: router}).$mount('#app') 声明路由链接和占位符在 src/App.vue 组件中，使用 vue-router 提供的 &lt;router-link&gt; 和 &lt;router-view&gt; 声明路由链接和占位符： 123456789101112&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;App组件&lt;/h1&gt; &lt;!-- 1．定义路由链接 --&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/movie&quot;&gt;电影&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;hr/&gt; &lt;!-- 2．定义路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 声明路由的匹配规则在 src/router/index.js 路由模块中，通过 routes 数组声明路由的匹配规则。示例代码如下： 1234567891011121314// 导入需要使用路由切换展示的组件import Home from '@/components/Home.vue'import Movie from '@/components/Movie.vue'import About from '@/components/About.vue'// 2．创建路由的实例对象const router = new VueRouter({ routes: [ // 在routes数组中，声明路由的匹配规则 // path 表示要匹配的 hash 地址; component 表示要展示的路由组件 { path: '/home', component: Home }, { path: '/movie', component: Movie }, { path: '/about', component: About } ]}) vue-router 的常见用法路由重定向路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。 通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向： 12345678910const router = new VueRouter( { //在 routes 数组中，声明路由的匹配规则 routes: [ //当用户访问 / 的时候，通过 redirect 属性跳转到 /home 对应的路由规则 { path: ' / ' , redirect: '/home' }， { path: '/home', component: Home }, { path: '/movie', component: Movie }， { path: '/about', component: About }]}) 嵌套路由通过路由实现组件的嵌套展示，叫做嵌套路由。 声明子路由链接和子路由占位符在 About.vue 组件中，声明 tab1 和 tab2 的子路由链接以及子路由占位符。示例代码如下： 123456789101112&lt;template&gt; &lt;div class=&quot;about-container&quot;&gt; &lt;h3&gt; About 组件&lt;/h3&gt; &lt;!-- 1．在关于页面中，声明两个子路由链接 --&gt; &lt;router-link to=&quot;/about/tab1&quot;&gt;tab1&lt;/router-link&gt; &lt;router-link to=&quot;/about/tab2&quot;&gt;tab2&lt;/router-link&gt; &lt;hr /&gt; &lt;!-- 2．在关于页面中，声明子路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 通过 children 属性声明子路由规则在 src/router/index.js 路由模块中，导入需要的组件，并使用 children 属性声明子路由规则： 123456789101112131415import Tab1 from '@/components/tabs/Tab1.vue'import Tab2 from '@/components/tabs/Tab2.vue'const router = new VueRouter({ routes: [ { // about页面的路由规则（父级路由规则) path: '/about ' , component: About, children: [ // 1．通过children属性，嵌套声明子级路由规则 { path: 'tab1', component: Tab1 }，// 2．访问/about/tab1时，展示 Tab1组件 { path: 'tab2', component: Tab2 } // 2．访问/about/tab2时，展示 Tab2组件 ] } ]}) 动态路由动态路由的概念动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。 在 vue-router 中使用英文的冒号（:）来定义路由的参数项。示例代码如下： 1234567// 路由中的动态参数以︰进行声明，冒号后面的是动态参数的名称{ path: '/movie/:id', component: Movie }// 将以下 3个路由规则，合并成了一个，提高了路由规则的复用性{ path: '/movie/1', component: Movie }{ path: '/movie/2', component: Movie }{ path: '/movie/3', component: Movie } $route.params 参数对象在动态路由渲染出来的组件中，可以使用 this.$route.params 对象访问到动态匹配的参数值。 123456789101112&lt;template&gt; &lt;div class=&quot;movie-container&quot;&gt; &lt;!-- this.$route 是路由的“参数对象” --&gt; &lt;h3&gt;Movie 组件 -- {{ this.$route.params.id }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Movie'}&lt;/script&gt; 使用 props 接收路由参数为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参。示例代码如下： 1234567891011121314// 1、在定义路由规则时，声明 props: true 选项，// 即可在 Movie 组件中，以 props 的形式接收到路由规则匹配到的参数项{ path: '/movie/:id', component: Movie, props: true}&lt;template&gt; &lt;!-- 3、直接使用 props 中接收的路由参数 --&gt; &lt;h3&gt;MyMovie组件 --- {{ id }}&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;export default { props: ['id'] //2、使用props接收路由规则中匹配到的参数项}&lt;/script&gt; 声明式导航 &amp; 编程式导航在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如： 普通网页中点击 &lt;a&gt; 链接、vue 项目中点击 &lt;router-link&gt; 都属于声明式导航 在浏览器中，调用 API 方法实现导航的方式，叫做编程式导航。例如： 普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航 vue-router 中的编程式导航 APIvue-router 提供了许多编程式导航的 API，其中最常用的导航 API 分别是： ① this.$router.push(‘hash 地址’) 跳转到指定 hash 地址，并增加一条历史记录 ② this.$router.replace(‘hash 地址’) 跳转到指定的 hash 地址，并替换掉当前的历史记录 ③ this.$router.go(数值 n) 实现导航历史前进、后退 **$router.**push调用 this.$router.push() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。示例代码如下 12345678910111213141516&lt;template&gt; &lt;div class=&quot;home-container&quot;&gt; &lt;h3&gt;Home 组件&lt;/h3&gt; &lt;button @click=&quot;gotoMovie&quot;&gt;跳转到 Movie 页面&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { methods: { gotoMovie() { this.$router.push('/ movie/1') } }}&lt;/script&gt; **$router.**replace调用 this.$router.replace() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。 push 和 replace 的区别： push 会增加一条历史记录 replace 不会增加历史记录，而是替换掉当前的历史记录 **$router.**go调用 this.$router.go() 方法，可以在浏览历史中前进和后退。示例代码如下： 12345678910111213&lt;template&gt; &lt;h3&gt;MyMovie 组件--- {{id}}&lt;/h3&gt; &lt;button @click=&quot;goBack&quot;&gt;后退&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default { props: ['id'], methods: { goBack() { this.$router.go(-1) } // 后退到之前的组件页面 },}&lt;/script&gt; **$router.**go 的简化用法在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法： ① $router.back() 在历史记录中，后退到上一个页面 ② $router.forward() 在历史记录中，前进到下一个页面 导航守卫导航守卫可以控制路由的访问权限。 例如：用户在未登录的情况下访问后台主页，导航守卫检测到未登录，会强制跳转到登录页面 全局前置守卫每次发生路由的导航跳转时，都会触发全局前置守卫。因此，在全局前置守卫中，程序员可以对每个路由进行 访问权限的控制： 123456// 创建路由实例对象const router = new VueRouter({ ... })// 调用路由实例对象的 beforeEach 方法，即可声明“全局前置守卫”// 每次发生路由导航跳转的时候，都会自动触发 fn 这个“回调函数”router.beforeEach(fn) 守卫方法的 3 个形参全局前置守卫的回调函数中接收 3 个形参，格式为： 123456789// 创建路由实例对象const router = new VueRouter({ ... })// 全局前置守卫router.beforeEach((to,from，next) =&gt; { // to 是将要访问的路由的信息对象 // from 是将要离开的路由的信息对象 // next 是一个函数，调用 next() 表示放行，允许这次路由导航} next 函数的 3 种调用方式当前用户拥有后台主页的访问权限，直接放行：next() 当前用户没有后台主页的访问权限，强制其跳转到登录页面：next('/login') 当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false) 控制后台主页的访问权限123456789101112router.beforeEach((to, from, next) =&gt; { if (to.path === '/main') { const token = localStorage.getItem('token') if(token) { next() // 访问的是后台主页，且有token的值 }else { next('/login') // 访问的是后台主页，但是没有token的值 } }else { next() // 访问的不是后台主页，直接放行 }})","link":"/2022/08/07/Vue2/"},{"title":"webpack","text":"webpack的基本使用什么是 webpack概念：webpack 是前端项目工程化的具体解决方案。 主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性 能优化等强大的功能。 好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。 注意：目前 Vue，React 等前端项目，基本上都是基于 webpack 进行工程化开发的。 创建列表隔行变色项目① 新建项目空白目录，并运行 npm init –y 命令，初始化包管理配置文件 package.json ② 新建 src 源代码目录 ③ 新建 src -&gt; index.html 首页和 src -&gt; index.js 脚本文件 ④ 初始化首页基本的结构 12345678910111213ul&gt;li{这是第 $ 个 li}*9//再回车，生成 &lt;ul&gt; &lt;li&gt;这是第 1 个 li&lt;/li&gt; &lt;li&gt;这是第 2 个 li&lt;/li&gt; &lt;li&gt;这是第 3 个 li&lt;/li&gt; &lt;li&gt;这是第 4 个 li&lt;/li&gt; &lt;li&gt;这是第 5 个 li&lt;/li&gt; &lt;li&gt;这是第 6 个 li&lt;/li&gt; &lt;li&gt;这是第 7 个 li&lt;/li&gt; &lt;li&gt;这是第 8 个 li&lt;/li&gt; &lt;li&gt;这是第 9 个 li&lt;/li&gt; &lt;/ul&gt; ⑤ 运行 npm install jquery –S 命令，安装 jQuery ( -S 是 –save 的缩写 ，表示安装在dependencies，开发和上线都需要) ⑥ 通过 ES6 模块化的方式导入 jQuery，实现列表隔行变色效果 1import $ from 'jquery' 在项目中安装 webpack在终端运行如下的命令，安装 webpack 相关的两个包： 1npm install webpack@5.42.1 webpack-cli@4.7.2 -D ( -D 是 –save-dev 的缩写 ，表示安装在devDependencies，仅开发需要的工具) 在项目中配置 webpack① 在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件，并初始化如下的基本配置： 1234// 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象module.exports = { mode: 'development' //mode 用来指定构建模式。可选值有 development（开发，打包速度快） 和 production（上线，体积小）} ② 在 package.json 的 scripts 节点下，新增 dev 脚本如下： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack&quot;}, ③ 在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包构建 mode 的可选值mode 节点的可选值有两个，分别是： ① development 开发环境 不会对打包生成的文件进行代码压缩和性能优化 打包速度快，适合在开发阶段使用 ② production 生产环境 会对打包生成的文件进行代码压缩和性能优化 打包速度很慢，仅适合在项目发布阶段使用 webpack.config.js 文件的作用 webpack.config.js 是 webpack 的配置文件。webpack 在真正开始打包构建之前，会先读取这个配置文件，从而基于给定的配置，对项目进行打包。 注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关的语法和模块进行 webpack 的个性化配置。 webpack 中的默认约定在 webpack 4.x 和 5.x 的版本中，有如下的默认约定： 默认的打包入口文件为 src -&gt; index.js 默认的输出文件路径为 dist -&gt; main.js 注意：可以在 webpack.config.js 中修改打包的默认约定 自定义打包的入口与出口在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。 123456789const path = require('path') // 导入 node.js 中专门操作路径的模块// 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象module.exports = { entry:path.join(__dirname, './src/index.js'), // 打包入口文件的路径 output: { path: path.join(__dirname, './dist'), // 输出文件的存放路径 filename: 'main.js' // 输出文件的名称 }} webpack 中的插件webpack 插件的作用通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的 webpack 插件有如下两个： webpack-dev-server 类似于 node.js 阶段用到的 nodemon 工具 每当修改了源代码，webpack 会自动进行项目的打包和构建 html-webpack-plugin webpack 中的 HTML 插件（类似于一个模板引擎插件） 可以通过此插件自定制 index.html 页面的内容 webpack-dev-serverwebpack-dev-server 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建。 安装 webpack-dev-server1npm install webpack-dev-server@3.11.2 -D 配置 webpack-dev-server① 修改 package.json -&gt; scripts 中的 dev 命令如下： 123&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack serve&quot;}, ② 再次运行 npm run dev 命令，重新进行项目的打包 ③ 在浏览器中访问 http://localhost:8080 地址，查看自动打包效果 打包生成的文件哪儿去了？① 不配置 webpack-dev-server 的情况下，webpack 打包生成的文件，会存放到实际的物理磁盘上 严格遵守开发者在 webpack.config.js 中指定配置 根据 output 节点指定路径进行存放 ② 配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中 不再根据 output 节点指定的路径，存放到实际的物理磁盘上 提高了实时打包输出的性能，因为内存比物理磁盘速度快很多 生成到内存中的文件该如何访问？webpack-dev-server 生成到内存中的文件，默认放到了项目的根目录中，而且是虚拟的、不可见的。 可以直接用 / 表示项目根目录，后面跟上要访问的文件名称，即可访问内存中的文件 例如 /bundle.js 就表示要访问 webpack-dev-server 生成到内存中的 bundle.js 文件 html-webpack-pluginhtml-webpack-plugin 是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html 页面的内容。 通过 html-webpack-plugin 插件，将 src 目录下的 index.html 首页，复制到项目根目录中一份！即可在根目录下打开 index.html 页面 安装 html-webpack-plugin运行如下的命令，即可在项目中安装此插件： 1npm install html-webpack-plugin@5.3.2 -D 配置 html-webpack-plugin修改 package.json文件 123456789101112// 导入 html-webpack-plugin 这个插件，得到插件的构造函数const HtmlPlugin = require('html-webpack-plugin')// new 构造函数，创建插件的实例对象const htmlPlugin = new HtmlPlugin({ template: './src/index.html', // 原文件路径和文件名 filename: './index.html' // 指定复制到的文件路径和文件名})module.exports = { mode: 'development', plugins: [htmlPlugin], // 插件的数组，通过plugins节点，使htmlPlugin插件生效} 解惑 html-webpack-plugin不需要导入js文件① 通过 HTML 插件复制到项目根目录中的 index.html 页面，也被放到了内存中 ② HTML 插件在生成的 index.html 页面，自动注入了同级目录下打包的 bundle.js 文件 devServer 节点在 webpack.config.js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置， 示例代码如下： 1234567module.exports = { devServer: { open: true, // 初次完成打包后，自动打开默认浏览器 host: '127.0.0.1', // 运行的主机地址 port: 80, // 打包的端口号 }} 注意：凡是修改了 webpack.config.js 配置文件，或修改了 package.json 配置文件，必须重启实时打包的服 务器，否则最新的配置文件无法生效！ webpack 中的 loaderloader 概述在实际开发过程中，webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块， webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！ loader 加载器的作用：协助 webpack 打包处理特定的文件模块。比如： css-loader 可以打包处理 .css 相关的文件 less-loader 可以打包处理 .less 相关的文件 babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 打包处理 css 文件① 运行 npm i style-loader@3.0.0 css-loader@5.2.6 -D 命令，安装处理 css 文件的 loader ② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： 12345module: { // 所有第三方文件模块的匹配规则 rules: [ // 文件后缀名的匹配规则 { test: /\\.css$/, use: ['style-loader', 'css-loader']} ]} 其中，test 表示匹配的文件类型， use 表示对应要调用的 loader 注意： use 数组中指定的 loader 顺序是固定的 多个 loader 的调用顺序是：从后往前调用 打包处理 less 文件① 运行 npm i less-loader@10.0.1 less@4.1.1 -D 命令 ② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： 12345module: { // 所有第三方文件模块的匹配规则 rules: [ // 文件后缀名的匹配规则 { test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader']} ]} 打包处理样式表中与 url 路径相关的文件① 运行 npm i url-loader@4.1.1 file-loader@6.2.0 -D 命令 ② 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： 12345module: { // 所有第三方文件模块的匹配规则 rules: [ // 文件后缀名的匹配规则 { test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22229'} ] } 其中 ? 之后的是 loader 的参数项： limit 用来指定图片的大小，单位是字节（byte） 只有 ≤ limit 大小的图片，才会被转为 base64 格式的图片 打包处理 js 文件中的高级语法webpack 只能打包处理一部分高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借 助于 babel-loader 进行打包处理。例如 webpack 无法处理下面的 JavaScript 代码 12345678910// 定义了名为 info 的装饰器function info(target) { // 为目标添加静态属性 info target.info = 'Person info'}// 为 Person 类应用 info 装饰器@infoclass Person {}// 打印 Person 的静态属性 infoconsole.log(Person.info) 安装 babel-loader 相关的包运行如下的命令安装对应的依赖包： 1npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： 12// 注意:必须使用 exclude 指定排除项;因为 node_modules 目录下的第三方包不需要被打包{ test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/} 配置 babel-loader在项目根目录下，创建名为 babel.config.js 的配置文件，定义 Babel 的配置项如下： 1234module.exports = { // 声明 babel 可用的插件 plugins: [['@babel/plugin-proposal-decorators', { legacy: true}]]} Babel 的官网 ：https://babeljs.io/docs/en/babel-plugin-proposal-decorators 打包发布为什么要打包发布项目开发完成之后，需要使用 webpack 对项目进行打包发布，主要原因有以下两点： 开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件 开发环境下，打包生成的文件不会进行代码压缩和性能优化 为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。 配置 webpack 的打包发布在 package.json 文件的 scripts 节点下，新增 build 命令如下： 1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack serve&quot;, // 开发环境中，运行 dev 命令 &quot;build&quot;: &quot;webpack --mode production&quot; // 项目发布时，运行 build 命令} --model 是一个参数项，用来指定 webpack 的运行模式。production 代表生产环境，会对打包生成的文件进行代码压缩和性能优化。 注意：通过 –model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项。 把 JavaScript 文件统一生成到 js 目录中在 webpack.config.js 配置文件的 output 节点中，进行如下的配置： 1234output: { path: path.join(__dirname, './dist'), // 输出文件的存放路径 filename: 'js/bundle.js' // 输出文件的名称} 把图片文件统一生成到 images 目录中修改 webpack.config.js 中的 module -&gt; rules 数组的 url-loader 配置项，新增 outputPath 参数即可指定图片文件的输出路径： 1{ test: /\\.jpg|png|gif$/, use: 'url-loader?limit=22229&amp;outputPath=images'} 自动清理 dist 目录下的旧文件为了在每次打包发布时自动清理掉 dist 目录中的旧文件，可以安装并配置 clean-webpack-plugin 插件 安装clean-webpack-plugin1npm i clean-webpack-plugin -D 配置使用clean-webpack-plugin①在 webpack.config.js 中的导入clean-webpack-plugin 1const { CleanWebpackPlugin } = require('clean-webpack-plugin') ②在 webpack.config.js 中的 module.exports 节点下的 plugins中 new CleanWebpackPlugin() 123module.exports = { plugins: [htmlPlugin, new CleanWebpackPlugin()], } Source Map什么是 Source MapSource Map 就是一个信息文件，里面储存着位置信息。也就是说，Source Map 文件中存储着压缩混淆后的 代码，所对应的转换前的位置。 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码，能够极大的方便后期的调试。 webpack 开发环境下的 Source Map在开发环境下，webpack 默认启用了 Source Map 功能。当程序运行出错时，可以直接在控制台提示错误行 的位置，并定位到具体的源代码。 默认 Source Map 的问题开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。 解决默认 Source Map 的问题开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数 保持一致 1234module.exports = { mode: 'development', devtool: 'eval-source-map' } webpack 生产环境下的 Source Map在生产环境下，如果省略了 devtool 选项，则最终生成的文件中不包含 Source Map。这能够防止原始代码通 过 Source Map 的形式暴露给其他人。 只定位行数不暴露源码在生产环境下，如果只想定位报错的具体行数，且不想暴露源码。此时可以将 devtool 的值设置为 nosources-source-map。 定位行数且暴露源码在生产环境下，如果想在定位报错行数的同时，展示具体报错的源码。此时可以将 devtool 的值设置为 source-map。（不推荐） Source Map 的最佳实践① 开发环境下： 建议把 devtool 的值设置为 eval-source-map 好处：可以精准定位到具体的错误行 ② 生产环境下： 建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map 好处：防止源码泄露，提高网站的安全性","link":"/2022/07/29/webpack/"},{"title":"JavaScript的一些学习","text":"写好JS的一些原则 各司其责 - 让HTML、CSS和JavaScript职能分离。 组件封装 - 好的UI组件具备正确性、扩展性、复用性。 过程抽象 - 应用函数式编程思想。 各司其责 - 控制一个网页，让它支持浅色和深色两种浏览模式。版本一：1234567891011121314151617181920&lt;body&gt; ... &lt;button id=&quot;modeBtn&quot;&gt;&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const btn = document.getElementById('modeBtn'); btn.addEventListener('click', function(e){ const body = document.body; if(e.target.innerHTML === '🌞') { body.style.backgroundColor = 'black'; body.style.color = 'white'; e.target.innerHTML = '🌜'; } else { body.style.backgroundColor = 'white'; body.style.color = 'black'; e.target.innerHTML = '🌞'; } }); &lt;/script&gt; 特点：在 js 代码里直接操作 css 样式，不推荐。 版本二：12345678910111213141516171819202122232425262728293031 &lt;style&gt; body.night { background-color: black; color: white; transition: all 1s; } #modeBtn::after{ content: '🌞'; } body.night #modeBtn::after{ content: '🌜'; } &lt;/style&gt;&lt;body&gt; ... &lt;button id=&quot;modeBtn&quot;&gt;&lt;/button&gt;&lt;/body&gt;&lt;script&gt; const btn = document.getElementById('modeBtn'); btn.addEventListener('click', (e) =&gt; { const body = document.body; if(body.className !== 'night') { body.className = 'night'; } else { body.className = ''; } });&lt;/script&gt; 特点：将 js 与 css 分离开，js里只是增加了类，推荐。 版本三：12345678910111213141516171819202122232425262728 &lt;style&gt; .content{ transition: all 1s; } #modeCheckBox { display: none; } #modeCheckBox:checked + .content { background-color: black; color: white; transition: all 1s; } #modeBtn::after{ content: '🌞'; } #modeCheckBox:checked + .content #modeBtn::after { content: '🌜'; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=&quot;modeCheckBox&quot; type=&quot;checkbox&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;label id=&quot;modeBtn&quot; for=&quot;modeCheckBox&quot; &gt;&lt;/label&gt; ... &lt;/div&gt;&lt;/body&gt; 特点，纯css实现，推荐。 注意： HTML/CSS/JS 各司其责 应当避免不必要的由 JS 直接操作样式 可以用 class 来表示状态 纯展示类交互寻求零 JS 方案 组件封装 - 用原生 JS 写一个电商网站的轮播图组件是指Web页面上抽出来一个个包含模版(HTML)、功能(JS)和样式(CSS)的单元。好的组件具备封装性、正确性、扩展性、复用性。 版本一（不加左右箭头和圆点选择）：结构轮播图是一个典型的列表结构，我们可以使用无序列表ul元素来实现。 1234567891011121314151617&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;slider-list__item--selected&quot;&gt; &lt;img src=&quot;https://p5.ssl.qhimg.com/t0119c74624763dd070.png&quot;&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg&quot;&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg&quot;&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg&quot;&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 表现 使用 CSS 绝对定位将图片重叠在同一个位置 轮播图切换的状态使用修饰符（modifier） 轮播图的切换动画使用 CSS transition 123456789101112131415161718192021#my-slider{ position: relative; width: 790px;}.slider-list ul{ list-style-type:none; position: relative; padding: 0; margin: 0;}.slider-list__item,.slider-list__item--selected{ position: absolute; transition: opacity 1s; opacity: 0; text-align: center;}.slider-list__item--selected{ transition: opacity 1s; opacity: 1;} 行为：APISlider 获取当前选中项： +getSelectedltem() 获取当前选中项的索引：+getSelectedltemlndex() 根据索引，跳转到指定位置图片：+slideTo() 跳转到下一张图片：+slideNext() 跳转到上一张图片：+slidePrevious( ) 123456789101112131415161718192021222324252627282930313233343536373839404142class Slider{ constructor(id){ this.container = document.getElementById(id); this.items = this.container .querySelectorAll('.slider-list__item, .slider-list__item--selected'); } getSelectedItem(){ const selected = this.container .querySelector('.slider-list__item--selected'); return selected } getSelectedItemIndex(){ return Array.from(this.items).indexOf(this.getSelectedItem()); } slideTo(idx){ const selected = this.getSelectedItem(); if(selected){ selected.className = 'slider-list__item'; } const item = this.items[idx]; if(item){ item.className = 'slider-list__item--selected'; } } slideNext(){ const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); } slidePrevious(){ const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); }}const slider = new Slider('my-slider');//slider.slideTo(3);setInterval(() =&gt; { slider.slideNext();},2000) 版本二（加上左右切换和下面圆点选择）：HTML123456789101112131415161718192021222324&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;slider-list__item--selected&quot;&gt; &lt;img src=&quot;https://p5.ssl.qhimg.com/t0119c74624763dd070.png&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg&quot;/&gt; &lt;/li&gt; &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg&quot;/&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt; &lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt; &lt;div class=&quot;slide-list__control&quot;&gt; &lt;span class=&quot;slide-list__control-buttons--selected&quot;&gt;&lt;/span&gt; &lt;span class=&quot;slide-list__control-buttons&quot;&gt;&lt;/span&gt; &lt;span class=&quot;slide-list__control-buttons&quot;&gt;&lt;/span&gt; &lt;span class=&quot;slide-list__control-buttons&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#my-slider{ position: relative; width: 790px; height: 340px;}.slider-list ul{ list-style-type:none; position: relative; width: 100%; height: 100%; padding: 0; margin: 0;}.slider-list__item,.slider-list__item--selected{ position: absolute; transition: opacity 1s; opacity: 0; text-align: center;}.slider-list__item--selected{ transition: opacity 1s; opacity: 1;}.slide-list__control{ position: relative; display: table; background-color: rgba(255, 255, 255, 0.5); padding: 5px; border-radius: 12px; bottom: 30px; margin: auto;}.slide-list__next,.slide-list__previous{ display: inline-block; position: absolute; top: 50%; margin-top: -25px; width: 30px; height:50px; text-align: center; font-size: 24px; line-height: 50px; overflow: hidden; border: none; background: transparent; color: white; background: rgba(0,0,0,0.2); cursor: pointer; opacity: 0; transition: opacity .5s;}.slide-list__previous { left: 0;}.slide-list__next { right: 0;}#my-slider:hover .slide-list__previous { opacity: 1;}#my-slider:hover .slide-list__next { opacity: 1;}.slide-list__previous:after { content: '&lt;';}.slide-list__next:after { content: '&gt;';}.slide-list__control-buttons,.slide-list__control-buttons--selected{ display: inline-block; width: 15px; height: 15px; border-radius: 50%; margin: 0 5px; background-color: white; cursor: pointer;}.slide-list__control-buttons--selected { background-color: red;} JS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Slider{ constructor(id, cycle = 3000){ this.container = document.getElementById(id); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = cycle; const controller = this.container.querySelector('.slide-list__control'); if(controller){ const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt=&gt;{ const idx = Array.from(buttons).indexOf(evt.target); if(idx &gt;= 0){ this.slideTo(idx); this.stop(); } }); controller.addEventListener('mouseout', evt=&gt;{ this.start(); }); this.container.addEventListener('slide', evt =&gt; { const idx = evt.detail.index const selected = controller.querySelector('.slide-list__control-buttons--selected'); if(selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }) } const previous = this.container.querySelector('.slide-list__previous'); if(previous){ previous.addEventListener('click', evt =&gt; { this.stop(); this.slidePrevious(); this.start(); evt.preventDefault(); }); } const next = this.container.querySelector('.slide-list__next'); if(next){ next.addEventListener('click', evt =&gt; { this.stop(); this.slideNext(); this.start(); evt.preventDefault(); }); } } getSelectedItem(){ let selected = this.container.querySelector('.slider-list__item--selected'); return selected } getSelectedItemIndex(){ return Array.from(this.items).indexOf(this.getSelectedItem()); } slideTo(idx){ let selected = this.getSelectedItem(); if(selected){ selected.className = 'slider-list__item'; } let item = this.items[idx]; if(item){ item.className = 'slider-list__item--selected'; } //自定义事件 const detail = {index: idx} const event = new CustomEvent('slide', {bubbles:true, detail}) this.container.dispatchEvent(event) } slideNext(){ let currentIdx = this.getSelectedItemIndex(); let nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); } slidePrevious(){ let currentIdx = this.getSelectedItemIndex(); let previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); } start(){ this.stop(); this._timer = setInterval(()=&gt;this.slideNext(), this.cycle); } stop(){ clearInterval(this._timer); }}const slider = new Slider('my-slider');slider.start(); 版本四：将 js 代码插件化解耦 将控制元素抽取成插件 插件与组件之间通过依赖注入方式建立联系 将 pluginController, pluginPrevious, pluginNext 抽离出来 js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104class Slider{ constructor(id, cycle = 3000){ this.container = document.getElementById(id); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = cycle; } registerPlugins(...plugins){ plugins.forEach(plugin =&gt; plugin(this)); } getSelectedItem(){ const selected = this.container.querySelector('.slider-list__item--selected'); return selected } getSelectedItemIndex(){ return Array.from(this.items).indexOf(this.getSelectedItem()); } slideTo(idx){ const selected = this.getSelectedItem(); if(selected){ selected.className = 'slider-list__item'; } const item = this.items[idx]; if(item){ item.className = 'slider-list__item--selected'; } const detail = {index: idx} const event = new CustomEvent('slide', {bubbles:true, detail}) this.container.dispatchEvent(event) } slideNext(){ const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); } slidePrevious(){ const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); } addEventListener(type, handler){ this.container.addEventListener(type, handler) } start(){ this.stop(); this._timer = setInterval(()=&gt;this.slideNext(), this.cycle); } stop(){ clearInterval(this._timer); }}function pluginController(slider){ const controller = slider.container.querySelector('.slide-list__control'); if(controller){ const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt=&gt;{ const idx = Array.from(buttons).indexOf(evt.target); if(idx &gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener('mouseout', evt=&gt;{ slider.start(); }); slider.addEventListener('slide', evt =&gt; { const idx = evt.detail.index const selected = controller.querySelector('.slide-list__control-buttons--selected'); if(selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }); } }function pluginPrevious(slider){ const previous = slider.container.querySelector('.slide-list__previous'); if(previous){ previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } }function pluginNext(slider){ const next = slider.container.querySelector('.slide-list__next'); if(next){ next.addEventListener('click', evt =&gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } }const slider = new Slider('my-slider');slider.registerPlugins(pluginController, pluginPrevious, pluginNext);slider.start(); 版本五：模板化将HTML模板化，更易于扩展 HTML1&lt;div id=&quot;my-slider&quot; class=&quot;slider-list&quot;&gt;&lt;/div&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150class Slider{ constructor(id, opts = {images:[], cycle: 3000}){ this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = opts.cycle || 3000; this.slideTo(0); } render(){ const images = this.options.images; const content = images.map(image =&gt; ` &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;${image}&quot;/&gt; &lt;/li&gt; `.trim()); return `&lt;ul&gt;${content.join('')}&lt;/ul&gt;`; } registerPlugins(...plugins){ plugins.forEach(plugin =&gt; { const pluginContainer = document.createElement('div'); pluginContainer.className = '.slider-list__plugin'; pluginContainer.innerHTML = plugin.render(this.options.images); this.container.appendChild(pluginContainer); plugin.action(this); }); } getSelectedItem(){ const selected = this.container.querySelector('.slider-list__item--selected'); return selected } getSelectedItemIndex(){ return Array.from(this.items).indexOf(this.getSelectedItem()); } slideTo(idx){ const selected = this.getSelectedItem(); if(selected){ selected.className = 'slider-list__item'; } let item = this.items[idx]; if(item){ item.className = 'slider-list__item--selected'; } const detail = {index: idx} const event = new CustomEvent('slide', {bubbles:true, detail}) this.container.dispatchEvent(event) } slideNext(){ const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); } slidePrevious(){ const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); } addEventListener(type, handler){ this.container.addEventListener(type, handler); } start(){ this.stop(); this._timer = setInterval(()=&gt;this.slideNext(), this.cycle); } stop(){ clearInterval(this._timer); }}const pluginController = { render(images){ return ` &lt;div class=&quot;slide-list__control&quot;&gt; ${images.map((image, i) =&gt; ` &lt;span class=&quot;slide-list__control-buttons${i===0?'--selected':''}&quot;&gt;&lt;/span&gt; `).join('')} &lt;/div&gt; `.trim(); }, action(slider){ const controller = slider.container.querySelector('.slide-list__control'); if(controller){ const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt =&gt; { const idx = Array.from(buttons).indexOf(evt.target); if(idx &gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener('mouseout', evt =&gt; { slider.start(); }); slider.addEventListener('slide', evt =&gt; { const idx = evt.detail.index const selected = controller.querySelector('.slide-list__control-buttons--selected'); if(selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }); } }};const pluginPrevious = { render(){ return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`; }, action(slider){ const previous = slider.container.querySelector('.slide-list__previous'); if(previous){ previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } }};const pluginNext = { render(){ return `&lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt;`; }, action(slider){ const previous = slider.container.querySelector('.slide-list__next'); if(previous){ previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } }};const slider = new Slider('my-slider', {images: ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png', 'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg', 'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg', 'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'], cycle:3000});slider.registerPlugins(pluginController, pluginPrevious, pluginNext);slider.start(); 版本六：组件框架抽象 将组件通用模型抽象出来 Slider：组件（可继承Component通用组件） Component：通用组件（两个抽象方法）registerPlugins：注册插件render：渲染 SliderPlugin：渲染 JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159class Component{ constructor(id, opts = {name, data:[]}){ this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); } registerPlugins(...plugins){ plugins.forEach(plugin =&gt; { const pluginContainer = document.createElement('div'); pluginContainer.className = `.${name}__plugin`; pluginContainer.innerHTML = plugin.render(this.options.data); this.container.appendChild(pluginContainer); plugin.action(this); }); } render(data) { /* abstract */ return '' }}class Slider extends Component{ constructor(id, opts = {name: 'slider-list', data:[], cycle: 3000}){ super(id, opts); this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected'); this.cycle = opts.cycle || 3000; this.slideTo(0); } render(data){ const content = data.map(image =&gt; ` &lt;li class=&quot;slider-list__item&quot;&gt; &lt;img src=&quot;${image}&quot;/&gt; &lt;/li&gt; `.trim()); return `&lt;ul&gt;${content.join('')}&lt;/ul&gt;`; } getSelectedItem(){ const selected = this.container.querySelector('.slider-list__item--selected'); return selected } getSelectedItemIndex(){ return Array.from(this.items).indexOf(this.getSelectedItem()); } slideTo(idx){ const selected = this.getSelectedItem(); if(selected){ selected.className = 'slider-list__item'; } const item = this.items[idx]; if(item){ item.className = 'slider-list__item--selected'; } const detail = {index: idx} const event = new CustomEvent('slide', {bubbles:true, detail}) this.container.dispatchEvent(event) } slideNext(){ const currentIdx = this.getSelectedItemIndex(); const nextIdx = (currentIdx + 1) % this.items.length; this.slideTo(nextIdx); } slidePrevious(){ const currentIdx = this.getSelectedItemIndex(); const previousIdx = (this.items.length + currentIdx - 1) % this.items.length; this.slideTo(previousIdx); } addEventListener(type, handler){ this.container.addEventListener(type, handler); } start(){ this.stop(); this._timer = setInterval(()=&gt;this.slideNext(), this.cycle); } stop(){ clearInterval(this._timer); }}const pluginController = { render(images){ return ` &lt;div class=&quot;slide-list__control&quot;&gt; ${images.map((image, i) =&gt; ` &lt;span class=&quot;slide-list__control-buttons${i===0?'--selected':''}&quot;&gt;&lt;/span&gt; `).join('')} &lt;/div&gt; `.trim(); }, action(slider){ let controller = slider.container.querySelector('.slide-list__control'); if(controller){ let buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected'); controller.addEventListener('mouseover', evt=&gt;{ var idx = Array.from(buttons).indexOf(evt.target); if(idx &gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener('mouseout', evt=&gt;{ slider.start(); }); slider.addEventListener('slide', evt =&gt; { const idx = evt.detail.index; let selected = controller.querySelector('.slide-list__control-buttons--selected'); if(selected) selected.className = 'slide-list__control-buttons'; buttons[idx].className = 'slide-list__control-buttons--selected'; }); } }};const pluginPrevious = { render(){ return `&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`; }, action(slider){ let previous = slider.container.querySelector('.slide-list__previous'); if(previous){ previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } }};const pluginNext = { render(){ return `&lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt;`; }, action(slider){ let previous = slider.container.querySelector('.slide-list__next'); if(previous){ previous.addEventListener('click', evt =&gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } }};const slider = new Slider('my-slider', {name: 'slide-list', data: ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png', 'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg', 'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg', 'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'], cycle:3000});slider.registerPlugins(pluginController, pluginPrevious, pluginNext);slider.start(); 总结 组件设计的原则：封装性、正确性、扩展性、复用性 实现组件的步骤：结构设计、展现效果、行为设计 三次重构 插件化 模板化 抽象化（组件框架） 过程抽象 用来处理局部细节控制的一些方法 函数式编程思想的基础应用 操作次数限制 一些异步交互 一次性的HTTP请求 once 函数，只调用一次 为了能够让“只执行一次“的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程我们称为过程抽象。 HTML1234567&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;button&gt;&lt;/button&gt;&lt;span&gt;任务一：学习HTML&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;button&gt;&lt;/button&gt;&lt;span&gt;任务二：学习CSS&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;button&gt;&lt;/button&gt;&lt;span&gt;任务三：学习JavaScript&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; CSS12345678910111213141516171819202122232425ul { padding: 0; margin: 0; list-style: none;}li button { border: 0; background: transparent; cursor: pointer; outline: 0 none;}li.completed { transition: opacity 2s; opacity: 0;}li button:before { content: '☑️';}li.completed button:before { content: '✅';} JS123456789101112131415161718192021function once(fn) { //外层 return function(...args) { //内层 if(fn) { const ret = fn.apply(this, args); fn = null; return ret; } }}const list = document.querySelector('ul');const buttons = list.querySelectorAll('button');buttons.forEach((button) =&gt; { button.addEventListener('click', once((evt) =&gt; { const target = evt.target; target.parentNode.className = 'completed'; setTimeout(() =&gt; { list.removeChild(target.parentNode); }, 2000); }));}); 高阶函数HOF 以函数作为参数 以函数作为返回值 常用于作为函数装饰器 12345function HOF0(fn) { return function(...args) { return fn.apply(this, args); }} once 函数（执行一次）123456789function once(fn) { return function(...args) { if(fn) { const ret = fn.apply(this, args); fn = null; return ret; } }} Throttle 函数（节流函数，固定时间间隔执行）1234567891011function throttle(fn, time = 500){ let timer; return function(...args){ if(timer == null){ fn.apply(this, args); timer = setTimeout(() =&gt; { timer = null; }, time) } }} 下面例子： HTML123每500毫秒可记录一次&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;&lt;div id=&quot;circle&quot;&gt;0&lt;/div&gt; CSS12345678910111213141516#circle { width: 50px; height: 50px; border-radius: 50%; background-color: red; line-height: 50px; text-align: center; color: white; opacity: 1.0; transition: opacity .25s;}#circle.fade { opacity: 0.0; transition: opacity .25s;} JS1234567891011121314151617function throttle(fn, time = 500){ let timer; return function(...args){ if(timer == null){ fn.apply(this, args); timer = setTimeout(() =&gt; { timer = null; }, time) } }}btn.onclick = throttle(function(e){ circle.innerHTML = parseInt(circle.innerHTML) + 1; circle.className = 'fade'; setTimeout(() =&gt; circle.className = '', 250);}); Debounce 函数（防抖函数）12345678910function debounce(fn, dur){ dur = dur || 100; var timer; return function(){ clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(this, arguments); }, dur); }} 下面例子： HTML12&lt;script src=&quot;https://s1.qhres2.com/!bd39e7fb/animator-0.2.0.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;bird&quot; class=&quot;sprite bird1&quot;&gt;&lt;/div&gt; CSS1234567891011121314151617181920212223html, body { margin:0; padding:0;}.sprite { display:inline-block; overflow:hidden; background-repeat: no-repeat; background-image:url(https://p1.ssl.qhimg.com/d/inn/0f86ff2a/8PQEganHkhynPxk-CUyDcJEk.png);}.bird0 {width:86px; height:60px; background-position: -178px -2px}.bird1 {width:86px; height:60px; background-position: -90px -2px}.bird2 {width:86px; height:60px; background-position: -2px -2px}#bird{ position: absolute; left: 100px; top: 100px; transform: scale(0.5); transform-origin: -50% -50%;} JS12345678910111213141516171819202122232425262728293031var i = 0;setInterval(function(){ bird.className = &quot;sprite &quot; + 'bird' + ((i++) % 3);}, 1000/10);function debounce(fn, dur){ dur = dur || 100; var timer; return function(){ clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(this, arguments); }, dur); }}document.addEventListener('mousemove', debounce(function(evt){ var x = evt.clientX, y = evt.clientY, x0 = bird.offsetLeft, y0 = bird.offsetTop; // console.log(x, y); var a1 = new Animator(1000, function(ep){ bird.style.top = y0 + ep * (y - y0) + 'px'; bird.style.left = x0 + ep * (x - x0) + 'px'; }, p =&gt; p * p); a1.animate();}, 100)); Consumer 函数123456789101112131415161718function consumer(fn, time){ let tasks = [], timer; return function(...args){ tasks.push(fn.bind(this, ...args)); if(timer == null){ timer = setInterval(() =&gt; { tasks.shift().call(this) if(tasks.length &lt;= 0){ clearInterval(timer); timer = null; } }, time) } }} Consumer 函数1 （间隔时间调用）下面例子： HTML:1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; JS12345678910111213141516171819202122232425262728293031function consumer(fn, time){ let tasks = [], timer; return function(...args){ tasks.push(fn.bind(this, ...args)); if(timer == null){ timer = setInterval(() =&gt; { tasks.shift().call(this) if(tasks.length &lt;= 0){ clearInterval(timer); timer = null; } }, time) } }}function add(ref, x){ const v = ref.value + x; console.log(`${ref.value} + ${x} = ${v}`); ref.value = v; return ref;}let consumerAdd = consumer(add, 1000);const ref = {value: 0};for(let i = 0; i &lt; 10; i++){ consumerAdd(ref, i);} Consumer 函数2 （延时调用）下面例子： HTML1234&lt;div id=&quot;main&quot;&gt; &lt;button id=&quot;btn&quot;&gt;Hit&lt;/button&gt; &lt;span id=&quot;count&quot;&gt;+0&lt;/span&gt;&lt;/div&gt; CSS 1234567891011121314151617181920212223#main { padding-top: 20px; font-size: 26px;}#btn { font-size: 30px; border-radius: 15px; border: solid 3px #fa0;}#count { position: absolute; margin-left: 6px; opacity: 1.0; transform: translate(0, 10px);}#count.hit { opacity: 0.1; transform: translate(0, -20px); transition: all .5s;} JS12345678910111213141516171819202122232425262728293031function consumer(fn, time){ let tasks = [], timer; return function(...args){ tasks.push(fn.bind(this, ...args)); if(timer == null){ timer = setInterval(() =&gt; { tasks.shift().call(this) if(tasks.length &lt;= 0){ clearInterval(timer); timer = null; } }, time) } }}btn.onclick = consumer((evt)=&gt;{ let t = parseInt(count.innerHTML.slice(1)) + 1; count.innerHTML = `+${t}`; count.className = 'hit'; let r = t * 7 % 256, g = t * 17 % 128, b = t * 31 % 128; count.style.color = `rgb(${r},${g},${b})`.trim(); setTimeout(()=&gt;{ count.className = 'hide'; }, 500);}, 800) Iterative 函数 （迭代函数，批量操作）123456789101112function iterative(fn) { return function(subject, ...rest) { if(isIterable(subject)) { const ret = []; for(let obj of subject) { ret.push(fn.apply(this, [obj, ...rest])); } return ret; } return fn.apply(this, [subject, ...rest]); }} 下面例子： HTML123456789&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt; &lt;li&gt;d&lt;/li&gt; &lt;li&gt;e&lt;/li&gt; &lt;li&gt;f&lt;/li&gt; &lt;li&gt;g&lt;/li&gt;&lt;/ul&gt; JS12345678910111213141516171819202122const isIterable = obj =&gt; obj != null &amp;&amp; typeof obj[Symbol.iterator] === 'function';function iterative(fn) { return function(subject, ...rest) { if(isIterable(subject)) { const ret = []; for(let obj of subject) { ret.push(fn.apply(this, [obj, ...rest])); } return ret; } return fn.apply(this, [subject, ...rest]); }}const setColor = iterative((el, color) =&gt; { el.style.color = color;});const els = document.querySelectorAll('li:nth-child(2n+1)');setColor(els, 'red'); 编程范式命令式（过程）1234567switcher.onclick = function(evt){ if(evt.target.className === 'on'){ evt.target.className = 'off'; }else{ evt.target.className = 'on'; }} 声明式（结果）123456789101112function toggle(...actions){ return function(...args){ let action = actions.shift(); actions.push(action); return action.apply(this, args); }}switcher.onclick = toggle( evt =&gt; evt.target.className = 'off', evt =&gt; evt.target.className = 'on');","link":"/2022/07/28/JavaScript%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"},{"title":"解决不能加载webpack-cli问题","text":"明明安装了webpack-cli包，却报Unable to load '@webpack-cli/serve' command错误 报错原因输入下面代码，查看webpack-cli的版本 12npx webpack --version复制代码 结果： 1234webpack 5.42.1webpack-cli 4.7.2webpack-dev-server 3.11.2复制代码 可能是 webpack-cli 版本不够，导致出现的错误。 解决方案不用卸载旧版本的 webpack-cli ，使用下面命令安装最新版本的 webpack-cli 1npm install -D webpack-cli","link":"/2022/07/27/%E8%A7%A3%E5%86%B3%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BDwebpack-cli%E9%97%AE%E9%A2%98/"},{"title":"解决JSON中不允许添加注释的问题","text":"vs code中如何解决JSON中不允许注释？ Comments are not permitted？ 错误显示： 解决方法：点击底部工具栏的 JSON 弹出的窗口中输入 json with Comments ,找到检索项后点击 再输入注释就正常了","link":"/2022/07/26/%E8%A7%A3%E5%86%B3JSON%E4%B8%AD%E4%B8%8D%E5%85%81%E8%AE%B8%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"在前端项目中使用MySQL","text":"在项目中操作数据库的步骤 安装操作 MySQL 数据库的第三方模块（mysql） 通过 mysql 模块连接到 MySQL 数据库 通过 mysql 模块执行 SQL 语句 安装与配置 mysql 模块安装 mysql 模块mysql 模块是托管于 npm 上的第三方模块。它提供了在 Node.js 项目中连接和操作 MySQL 数据库的能力。 想要在项目中使用它，需要先运行如下命令，将 mysql 安装为项目的依赖包： 1npm i mysql 配置 mysql 模块在使用 mysql 模块操作 MySQL 数据库之前，必须先对 mysql 模块进行必要的配置，主要的配置步骤如下： 123456789// 1. 导入 mysql 模块const mysql = require('mysql')// 2. 建立与 MySQL 数据库的连接关系const db = mysql.createPool({ host: '127.0.0.1', // 数据库的 IP 地址 user: 'root', // 登录数据库的账号 password: 'root', // 登录数据库的密码 database: 'mydb', // 指定要操作哪个数据库}) 测试 mysql 模块能否正常工作调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果： 1234567// 测试 mysql 模块能否正常工作db.query('select 1', (err, results) =&gt; { // mysql 模块工作期间报错了 if(err) return console.log(err.message) // 能够成功的执行 SQL 语句 console.log(results)}) 使用 mysql 模块操作 MySQL 数据库查询数据查询 users 表中所有的数据： 123456789// 查询 users 表中所有的数据const sqlStr = 'select * from users'db.query(sqlStr, (err, results) =&gt; { // 查询数据失败 if (err) return console.log(err.message) // 查询数据成功 // 注意：如果执行的是 select 查询语句，则执行的结果是数组 console.log(results)}) 插入数据向 users 表中新增数据， 其中 username 为 Spider-Man，password 为 pcc321： 123456789101112131415// 向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123const user = { username: 'Spider-Man', password: 'pcc123' }// 定义待执行的 SQL 语句const sqlStr = 'insert into users (username, password) values (?, ?)'// 执行 SQL 语句db.query(sqlStr, [user.username, user.password], (err, results) =&gt; { // 执行 SQL 语句失败了 if (err) return console.log(err.message) // 成功了 // 注意：如果执行的是 insert into 插入语句，则 results 是一个对象 // 可以通过 affectedRows 属性，来判断是否插入数据成功 if (results.affectedRows === 1) { console.log('插入数据成功!') }}) 插入数据的便捷方式向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据： 1234567891011// 插入数据的便捷方式const user = { username: 'Spider-Man2', password: 'pcc4321' }// 定义待执行的 SQL 语句const sqlStr = 'insert into users set ?'// 执行 SQL 语句db.query(sqlStr, user, (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) { console.log('插入数据成功') }}) 更新数据可以通过如下方式，更新表中的数据： 123456789101112// 更新用户的信息const user = { id: 6, username: 'aaa', password: '000' }// 定义 SQL 语句const sqlStr = 'update users set username=?, password=? where id=?'// 执行 SQL 语句db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; { if (err) return console.log(err.message) // 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功 if (results.affectedRows === 1) { console.log('更新成功') }}) 更新数据的便捷方式更新表数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速更新表数据： 1234567891011// 更新数据的便捷方式const user = { id: 6, username: 'aaaa', password: '0000' }// 定义 SQL 语句const sqlStr = 'update users set ? where id=?'// 执行 SQL 语句db.query(sqlStr, [user, user.id], (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) { console.log('更新数据成功') }}) 删除数据在删除数据时，推荐根据 id 这样的唯一标识，来删除对应的数据。示例如下： 123456789// 删除 id 为 5 的用户const sqlStr = 'delete from users where id=?'db.query(sqlStr, 5, (err, results) =&gt; { if (err) return console.log(err.message) // 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性 if (results.affectedRows === 1) { console.log('删除数据成功') }}) 标记删除使用 DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。 所谓的标记删除，就是在表中设置类似于 status 这样的状态字段，来标记当前这条数据是否被删除。 当用户执行了删除的动作时，我们并没有执行 DELETE 语句把数据删除掉，而是执行了 UPDATE 语句，将这条数据对应的 status 字段标记为删除即可。 12345678// 标记删除const sqlStr = 'update users set status=? where id=?'db.query(sqlStr, [0, 6], (err, results) =&gt; { if (err) return console.log(err.message) if (results.affectedRows === 1) { console.log('标记删除成功') }})","link":"/2022/07/20/%E5%9C%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MySQL/"},{"title":"npm与包的使用","text":"包什么是包Node.js 中的第三方模块又叫做包。 包的来源不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。 为什么需要包由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。 包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。 包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。 从哪里下载包国外有一家 IT 公司，叫做 npm, Inc. 这家公司旗下有一个非常著名的网站： https://www.npmjs.com/ ，它是全球最大的包共享平台，可以从这个网站上搜索到任何你需要的包。 npm, Inc. 公司提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。 如何下载包npm, Inc. 公司提供了一个包管理工具，Node Package Manager（简称 npm 包管理工具），这个包管理工具随着 Node.js 的安装包一起被安装到了用户的电脑上。 格式化时间传统案例15.dateFormat.js文件 1234567891011121314151617181920212223// 1. 定义格式化时间的方法function dateFormat(dtStr) { const dt = new Date(dtStr) const y = dt.getFullYear() const m = padZero(dt.getMonth() + 1) const d = padZero(dt.getDate()) const hh = padZero(dt.getHours()) const mm = padZero(dt.getMinutes()) const ss = padZero(dt.getSeconds()) return `${y}-${m}-${d} ${hh}:${mm}:${ss}` } // 定义补零的函数 function padZero(n) { return n &gt; 9 ? n : '0' + n } module.exports = { dateFormat } 调用： 12345678// 导入自定义的格式化时间的模块const TIME = require('./15.dateFormat')// 调用方法，进行时间的格式化const dt = new Date()// console.log(dt)const newDT = TIME.dateFormat(dt)console.log(newDT) npm格式化时间在项目中安装包 123npm install moment或npm i moment 调用： 123456// 1. 导入需要的包// 注意：导入的名称，就是装包时候的名称const moment = require('moment')const dt = moment().format('YYYY-MM-DD HH:mm:ss')console.log(dt) 安装指定版本的包默认情况下，使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本例如： 1npm i moment@2.22.2 初次装包后多了哪些文件初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。 其中： node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。 注意：不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。 包的语义化版本规范包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0其中每一位数字所代表的的含义如下： 第1位数字：大版本 第2位数字：功能版本 第3位数字：Bug修复版本 版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。 包管理配置文件npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置信息。例如： 项目的名称、版本号、描述等 项目中都用到了哪些包 哪些包只在开发期间会用到 那些包在开发和部署时都需要用到 多人协作的问题第三方包的体积过大，不方便团队成员之间共享项目源代码。 解决方案：共享时剔除node_modules 如何记录项目中安装了哪些包在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。 注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。 快速创建 package.jsonnpm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件： 1npm init -y 注意： 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。 dependencies 节点package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。例如： 123&quot;dependencies&quot;: { &quot;moment&quot;: &quot;^2.29.4&quot;} 一次性安装所有的包当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。否则会报类似于下面的错误： 12# 由于项目运行依赖于moment这个包，如果没有提前安装好这个包，就会报如下的错误:Error: Cannot find module 'moment' 可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包： 123# 执行npm install 命令时，npm包管理工具会先读取 package.json 中的 dependencies节点，# 读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中npm install 卸载包可以运行 npm uninstall 命令，来卸载指定的包： 12# 使用npm uninstall具体的包名来卸载包npm uninstall moment 注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。 devDependencies 节点如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。 可以使用如下的命令，将包记录到 devDependencies 节点中： 1234# 安装指定的包，并记录到devDependencies节点中npm i 包名 -D# 注意:上述命令是简写形式，等价于下面完整的写法:npm install 包名 --save-dev 解决下包速度慢的问题为什么下包速度慢在使用 npm 下包的时候，默认从国外的 https://registry.npmjs.org/ 服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。 淘宝 NPM 镜像服务器淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。 扩展：镜像（Mirroring）是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。 切换 npm 的下包镜像源下包的镜像源，指的就是下包的服务器地址。 123456# 查看当前的下包镜像源npm config get registry# 将下包的镜像源切换为淘宝镜像源npm config set registry=https://registry.npm.taobao.org/# 检查镜像源是否下载成功npm config get registry nrm为了更方便的切换下包的镜像源，我们可以安装 nrm 这个工具，利用 nrm 提供的终端命令，可以快速查看和切换下包的镜像源。 123456# 通过npm包管理器，将nrm安装为全局可用的工具npm i nrm -g# 查看所有可用的镜像源nrm ls# 将下包的镜像源切换为taobao镜像nrm use taobao 包的分类使用 npm 包管理工具下载的包，共分为两大类，分别是： 项目包 全局包 项目包那些被安装到项目的 node_modules 目录中的包，都是项目包。 项目包又分为两类，分别是： 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到） 1234# 开发依赖包(会被记录到devDependencies节点下)npm i 包名 -D# 核心依赖包(会被记录到dependencies节点下)npm i 包名 全局包在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。 全局包会被安装到 C:\\Users\\用户目录\\AppData\\Roaming\\npm\\node_modules 目录下。 1234# 全局安装指定的包npm i 包名 -g# 卸载全局安装的包npm uninstall 包名 -g 注意： 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。 i5ting_toci5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下： 1234# 将i5ting_toc安装为全局包npm install -g i5ting _toc#调用i5ting _toc，实现 md 转 html 的功能i5ting_toc -f 要转换的md文件路径 -o 规范的包结构一个规范的包，它的组成结构，必须符合以下 3 点要求： 包必须以单独的目录而存在 包的顶级目录下要必须包含 package.json 这个包管理配置文件 package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。 注意：以上 3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/configuration/manifest 开发属于自己的包例如npm-test-tools包： 需要实现的功能 格式化日期 转义 HTML 中的特殊字符 还原 HTML 中的特殊字符 初始化包的基本结构新建 npm-test-tools 文件夹，作为包的根目录在 npm-test-tools 文件夹中，新建如下三个文件以及一个文件夹： package.json （包管理配置文件） index.js （包的入口文件） README.md （包的说明文档） src 文件夹 （模块化功能） 初始化 package.json12345678{ &quot;name&quot; : &quot;npm-test-tools&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot; : &quot;index.js&quot;, &quot;description&quot;:&quot;提供了格式化时间，HTMLEscape的功能&quot;, &quot;keywords&quot;: [&quot;npm&quot;, &quot;dateFormat&quot;, &quot;escape&quot;], &quot;license&quot; : &quot;ISC&quot;} 在该目录下的src目录下的dateFormat.js 中定义格式化时间的方法12345678910111213141516171819// 定义格式化时间的方法function dateFormat(dtStr) { const dt = new Date(dtStr) const y = dt.getFullYear() const m = padZero(dt.getMonth() + 1) const d = padZero(dt.getDate()) const hh = padZero(dt.getHours()) const mm = padZero(dt.getMinutes()) const ss = padZero(dt.getSeconds()) return `${y}-${m}-${d} ${hh}:${mm}:${ss}` } // 定义补零的函数 function padZero(n) { return n &gt; 9 ? n : '0' + n } 在该目录下的src目录下的dateFormat.js 中声明module.exports1234// 向外暴露需要的成员 module.exports = { dateFormat } 在该目录下的src目录下的htmlEscape.js 中定义定义转义 HTML 字符的方法123456789101112131415// 定义转义 HTML 字符的函数function htmlEscape(htmlstr) { return htmlstr.replace(/&lt;|&gt;|&quot;|&amp;/g, match =&gt; { switch (match) { case '&lt;': return '&amp;lt;' case '&gt;': return '&amp;gt;' case '&quot;': return '&amp;quot;' case '&amp;': return '&amp;amp;' } })} 在该目录下的src目录下的htmlEscape.js 中定义还原 HTML 的方法123456789101112131415// 定义还原 HTML 字符串的函数function htmlUnEscape(str) { return str.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, match =&gt; { switch (match) { case '&amp;lt;': return '&lt;' case '&amp;gt;': return '&gt;' case '&amp;quot;': return '&quot;' case '&amp;amp;': return '&amp;' } })} 在该目录下的src目录下的htmlEscape.js 中声明module.exports12345// 向外暴露需要的成员module.exports = { htmlEscape, htmlUnEscape} 在 index.js 中，导入两个模块，得到需要向外共享的方法1234// 这是包的入口文件const date = require('./src/dateFormat')const escape = require('./src/htmlEscape')} 在 index.js 中，使用 module.exports 把对应的方法共享出去12345// 向外暴露需要的成员module.exports = { ...date, ...escape} 编写包的说明文档包根目录中的 README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以 markdown 的格式写出来，方便用户参考。 README.md 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。 这个包的 README.md 文档中，包含以下 6 项内容： 安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议。 测试1234567891011121314const test = require('./npm-test-tools')// 格式化时间的功能const dtStr = test.dateFormat(new Date())console.log(dtStr)console.log('-----------')const htmlStr = '&lt;h1 title=&quot;abc&quot;&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt;'const str = test.htmlEscape(htmlStr)console.log(str)console.log('-----------')const str2 = test.htmlUnEscape(str)console.log(str2) 结果： 123452022-07-10 18:32:17-----------&amp;lt;h1 title=&amp;quot;abc&amp;quot;&amp;gt;这是h1标签&amp;lt;span&amp;gt;123&amp;amp;nbsp;&amp;lt;/span&amp;gt;&amp;lt;/h1&amp;gt;-----------&lt;h1 title=&quot;abc&quot;&gt;这是h1标签&lt;span&gt;123&amp;nbsp;&lt;/span&gt;&lt;/h1&gt; 发布包注册 npm 账号 访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面 填写账号相关的信息：Username、Email address、Password 勾选同意许可 点击 Create an Account 按钮，注册账号 邮箱一次性密码验证 终端登录 npm 账号npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱（一次性密码验证邮箱）后，即可登录成功。 注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！ 把包发布到 npm 上将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能和 npm 官网上的重复）。 会有邮件提示包发布成功。 在https://www.npmjs.com/ 登录后，可在头像菜单选项下的Packages下查看自己发布的包。 删除已发布的包运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。注意： npm unpublish 命令只能删除 72 小时以内发布的包 npm unpublish 删除的包，在 24 小时内不允许重复发布 发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！","link":"/2022/07/10/npm%E4%B8%8E%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"hexo配置主题","text":"正如该博客封面图所示，主题配置成自己想要的效果不太容易，好多不懂，网上查有的也查不到结果。 所以搞多少算多少，之后再慢慢补吧。 安装主题在官网选择自己想要的主题：https://hexo.io/themes/ Git来克隆主题的代码仓库到themes目录下1git clone https://github.com/ppoffice/hexo-theme-主题名.git themes/主题名 切换主题_config.yml文件中的修改theme属性1theme: 主题名 主题适配一些前言需要配置站点下_config.主题名.yml的内容。 一般站点下和主题目录下都会有_config.yml文件。 但是由于主题编写语言不同，导致有的主题文件下的默认配置文件_config.yml不存在。有该文件可用其对不同页面进行配置。 _config.主题名.yml配置版本1version: 5.0.0 主题皮肤1variant: default logo123# logo: /img/logo.svg #logo,可用图片或文字logo: text: SummlBlog 菜单导航栏图标12head: : /ifaviconmg/favicon.svg 导航栏1234567891011navbar: menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about links: GitHub: icon: fab fa-github url: https://github.com/Summl 页脚123456789101112footer: links: # Creative Commons: # icon: fab fa-creative-commons # url: https://creativecommons.org/ # Attribution 4.0 International: # icon: fab fa-creative-commons-by # url: https://creativecommons.org/licenses/by/4.0/ # Download on GitHub: My GitHub: icon: fab fa-github url: https://github.com/Summl 文章theme：可对代高亮显示设置 clipboard：代码复制按钮 fold：折叠或展开所有代码块 readtime：阅读整篇文章大概所需时间时间 update_time：文章更新时间 123456789101112131415161718article: highlight: # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light clipboard: true fold: unfolded readtime: true update_time: true licenses: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Noncommercial: icon: fab fa-creative-commons-nc url: https://creativecommons.org/licenses/by-nc/4.0/ 搜索框12search: type: insight 评论、打赏、分享需要专门设置 12345678910111213141516171819202122232425262728# comment:# type: disqus# shortname: '' # donates:# -# type: afdian# url: ''# -# type: alipay# qrcode: ''# -# type: buymeacoffee# url: ''# -# type: patreon# url: ''# -# type: paypal# business: ''# currency_code: USD# -# type: wechat# qrcode: ''# share:# type: sharethis# install_url: '' 侧栏固定12345sidebar: left: sticky: false right: sticky: false 侧栏配置position设置right会变三栏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374widgets: - position: left type: profile author: Summl author_title: '一枚无名小辈' location: '中国' avatar: avatar_rounded: false gravatar: follow_link: https://Summl.github.io/ social_links: Github: icon: fab fa-github url: https://Summl.github.io/ Facebook: icon: fab fa-facebook url: https://facebook.com Twitter: icon: fab fa-twitter url: https://twitter.com Dribbble: icon: fab fa-dribbble url: https://dribbble.com RSS: icon: fas fa-rss url: / - position: left type: toc index: true collapsed: true depth: 3 - position: left type: links links: # Hexo: https://hexo.io # Bulma: https://bulma.io gitee: https://gitee.com/ma-jia-le Email: 1870949565@qq.com 稀土掘金: https://juejin.cn/user/4002677701488424 简书: https://www.jianshu.com/u/8121c6bc7a9a - position: left type: recent_posts - position: left type: categories - position: left type: archives - position: left type: tags - position: left # type: subscribe_email type: # description: # feedburner_id: '' - position: left # type: adsense type: client_id: '' slot_id: '' - position: left # type: followit type: # description: # action_url: '' # verification_code: '' 网站访问量与访客量统计修改主题配置文件，_config.文件名.yml文件 1busuanzi: true source\\_posts博客设置博客头部设置12345678910title: Hexo+GitHub自建博客 #博客标题 date: 2022-07-06 14:07:14 #创建博客时间cover: /gallery/Hexo+GitHub自建博客/图1.jpg #博客封面thumbnail: /gallery/Hexo+GitHub自建博客/图1.jpg #博客缩略图tags: #标签 可以多个 - GitHub - Hexocategories: #分类 可多级目录 - 关于博客（一级分类目录） - 二级分类目录 图片需要在source目录下新建gallery目录 主页博客添加阅读全文按钮在文章中截断地方添加 1&lt;!--more--&gt; 新建文章头部模板在scaffolds目录下的post.md文件里设置 例如： 12345678title: {{ title }}date: {{ date }}cover: /gallery/{{ title }}/图1.jpgthumbnail: /gallery/{{ title }}/图1.jpgtags: - categories: - 文章置顶安装如下插件 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 需要置顶的文章头部再增加如下属性配置 1top: true 注：可以设置true，也可以设置置顶的编号顺序，例如top: 1 文章目录显示站点下的_config.yml文件里添加 1toc: true 在主题的_config.post.yml文件下可进行设置 12345position: left type: toc index: true collapsed: true depth: 3 目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 source/js/main.js文件123 if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); include/style/widget.styl文件123+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 博客内容插入图片修改博客根目录中_config.yml文件的配置项post_asset_folder为true 完成此设置后，当你通过hexo new 文件名新建博客后，会产生一个和文件同名的文件夹。 在博客根目录中下使用npm安装插件： 1npm install https://github.com/CodeFalling/hexo-asset-image --save 当文章需要添加图片时，将需要添加的图片放入同名的文件夹中，同时通过相对路径索引到该图片。 1![示例](./解决Hexo博客不显示图片的一种方法/1.png) 页面设置新建标签 tags 页面如果在 source 目录下还没有 tags/index.md 文件，那么就需要新建一个 1hexo new page &quot;tags&quot; 编辑刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 1234title: tagesdate: 2022-07-07 18:55:10type: tagslayout: tags 分类 categories 页面、关于我 about 页面同上about关于页面信息展示在source 目录下还没有 about.md 文件填写内容 博客布局分栏设置通过配置的方式把所有文章变为两栏布局，其他页面设置为三栏布局 在站点下的_config.yml文件把需要的widget分别显示在left和right 在_config.post.yml文件把需要的widget显示在left 但两栏整体宽度跟三栏不同，因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 layout/layout.jsx文件1234 &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; layout/layout.jsx文件1234 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 layout/common/widgets.jsx文件12345678 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 并优化在不同屏幕小大下的宽度 include/style/responsive.styl文件1234567891011121314151617+widescreen()+ .is-3-column .containe+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap+fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap","link":"/2022/07/08/hexo%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98/"},{"title":"搞博客遇到的一些问题","text":"问题一：本地能显示博客，GitHub地址显示不出来博客在复制id_rsa.pub文件里的内容，粘贴到Github的SSH and GPG keys里时，直接粘贴，不要删除换行符之类。 问题二：FATAL Port 4000 has been used. Try other port instead.在启动服务加上端口号： 1hexo server -p 4001 问题三：git clone unable to access ‘XXX‘: OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054方式一：解除ssl验证后，再次git：命令行运行 1git config --global http.sslVerify &quot;false&quot; 方式二：加大缓存大小 1git config --global http.postBuffer 524288000 问题四：GitHub建仓库时忘记建READ.ME文件在根目录的source 文件夹下新建README.md文件 然而当我们执行 hexo g -d 部署博客的时候会发现README.md变成了 README.html。GitHub上也只有README.html文件。 原因是当我们在执行 hexo g -d 命令时，.md 文件会被转化成.html 文件，并将这些文件放到 public 目录里，最后再提交到远程 GitHub 仓库，而 Hexo 也提供了一个方法，让.md 文件不被转换成.html 文件，在根目录的 _config.yml 配置文件里，找到 skip_render 关键字，添加 README.md，让解释器跳过渲染就行了： 1skip_render: README.md 一些注意项注意一：在注释一些选项时要把上面的-一起注释，否则会报错 123# -# position: left# type: toc ：后面有一个空格 注意二：有的主题目录里没有_config.post.yml文件，导致一些功能不能设置。 可手动在_config.主题名.yml 同级目录下自行创建。","link":"/2022/07/08/%E6%90%9E%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"Hexo+GitHub自建博客","text":"下载安装软件Git、Node.js、Hexo 下载安装Hexo命令1npm install -g hexo-cli Hexo命令,生成本地博客初始化Hexo，根目录下1hexo init 安装博客所需要的依赖文件1npm install 生成静态页面至public目录123hexo generate或hexo g 开启预览访问端口（默认端口4000，ctrl + c 关闭 server ，地址：http://localhost:4000/ ）123hexo server或 hexo s 如果4000端口被占用，可更换端口1hexo s -p 4001 部署到GitHub123hexo deploy或 hexo d 清除缓存文件 (db.json) 和已生成的静态文件 (public)1hexo clean 新建文章123hexo new &quot;postName&quot;或 hexo n &quot;postName&quot; 组合命令生成并本地预览1hexo s -g 生成并上传1hexo d -g 本地博客发布到GitHub命令在博客目录下，安装发布的插件1npm install hexo-deployer-git --save 将本地目录与GitHub关联起来 1ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; 一直回车，直到能输入命令。然后在C:/Users/[username]目录下找到名为.ssh的文件夹， 文件夹内会有两个文件，一个id_rsa.pub一个id_rsa，用文本编辑器打开id_rsa.pub，复制里面的的内容。 打开Github，点击右上角的头像 Settings 选择SSH and GPG keys。点击New SSH key 将之前复制的内容粘帖到Key的框中。 上面的Title可以随意，点击Add SSH key 完成添加。（注意不要删除粘贴的换行符） 回到Git的命令行界面，测试一下是否与GitHub连接成功1ssh -T git@github.com 点击回车，然后会出现一个询问内容，输入yes，回车，会出现一段内容，Hi &lt;account name&gt;! You've successfully authenticated, but GitHub doesnot provide shell access.。 说明连接成功。此处这个&lt;account name&gt;应该是你Github的用户名。 修改Hexo配置文件进入博客站点目录，用文本编辑器打开_config.yml1234567title: 你的博客名subtitle: 博客的副标题，有些主题支持description: 博客描述keywords: 博客关键词author: 作者，在文章中显示language: 博客语言语种 timezone: 时区 1url: 修改为https://&lt;用户名&gt;.github.io 滑到文件最底部，有一个deploy，在deploy下面添加一个repo项 ，一个branch项。 1234type: gitrepo: git@github.com:&lt;Github用户名&gt;/&lt;Github用户名&gt;.github.io.git #也可使用https地址，如：https://github.com/&lt;Github用户名&gt;/&lt;Github用户名&gt;.github.io.git branch: master 生成页面 123hexo cleanhexo g -dhexo s 在浏览器中打开https://&lt;用户名&gt;.github.io，查看上传的网页。","link":"/2022/07/06/Hexo+GitHub%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"自建包","slug":"自建包","link":"/tags/%E8%87%AA%E5%BB%BA%E5%8C%85/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"高阶函数","slug":"高阶函数","link":"/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"}],"categories":[{"name":"关于博客","slug":"关于博客","link":"/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JSON","slug":"JSON","link":"/categories/JSON/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"}]}